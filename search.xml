<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6数组对象新增方法</title>
    <url>/2021/04/11/ES6%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-Array-from"><a href="#1-Array-from" class="headerlink" title="1. Array.from()"></a>1. Array.from()</h3><p>Array.from 方法用于将两类对象转为真正的数组：类数组的对象（ array-like object ）和可遍历（ iterable ）的对象（包括 ES6 新增的数据结构 Set 和 Map ）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arrayLike &#x3D; &#123;</span><br><span class="line">　　&#39;0&#39;: &#39;a&#39;,</span><br><span class="line">　　&#39;1&#39;: &#39;b&#39;,</span><br><span class="line">　　&#39;2&#39;: &#39;c&#39;,</span><br><span class="line">　　length: 3</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; ES5 的写法</span><br><span class="line">var arr1 &#x3D; [].slice.call(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">&#x2F;&#x2F; ES6 的写法</span><br><span class="line">let arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NodeList 对象</span><br><span class="line">let ps &#x3D; document.querySelectorAll(&#39;p&#39;);</span><br><span class="line">Array.from(ps).forEach(function (p) &#123;</span><br><span class="line">　　console.log(p);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; arguments 对象</span><br><span class="line">function foo() &#123;</span><br><span class="line">var args &#x3D; Array.from(arguments);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字符串转换为字符数组str.split(&#39;&#39;)</span><br><span class="line">Array.from(&#39;hello&#39;)  &#x2F;&#x2F; [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</span><br><span class="line">let namesSet &#x3D; new Set([&#39;a&#39;, &#39;b&#39;])</span><br><span class="line">Array.from(namesSet) &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;]</span><br><span class="line"></span><br><span class="line">Array.from(&#123; length: 3 &#125;);  &#x2F;&#x2F; [ undefined, undefined, undefined ]</span><br></pre></td></tr></table></figure>

<p>对于还没有部署该方法的浏览器，可以用 Array.prototype.slice 方法替代：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const toArray &#x3D; (() &#x3D;&gt;</span><br><span class="line">  Array.from ? Array.from : obj &#x3D;&gt; [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>

<p>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.from(arrayLike, x &#x3D;&gt; x * x);</span><br><span class="line">&#x2F;&#x2F;  等同于</span><br><span class="line">Array.from(arrayLike).map(x &#x3D;&gt; x * x);</span><br><span class="line">Array.from([1, 2, 3], (x) &#x3D;&gt; x * x)</span><br><span class="line">&#x2F;&#x2F; [1, 4, 9]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Array.from回调函数</span><br><span class="line">var arr1 &#x3D; Array.from([1,2,3], function(item)&#123;</span><br><span class="line">    return item*item;</span><br><span class="line">&#125;);</span><br><span class="line">var arr2 &#x3D; Array.from([1,2,3]).map(function(item)&#123;</span><br><span class="line">    return item*item;</span><br><span class="line">&#125;);</span><br><span class="line">var arr3 &#x3D; Array.from([1,2,3], (item) &#x3D;&gt; item*item);</span><br><span class="line"></span><br><span class="line">console.log(arr1); &#x2F;&#x2F;[ 1, 4, 9 ]</span><br><span class="line">console.log(arr2); &#x2F;&#x2F;[ 1, 4, 9 ]</span><br><span class="line">console.log(arr3); &#x2F;&#x2F;[ 1, 4, 9 ]</span><br></pre></td></tr></table></figure>

<p>还有就是扩展运算符(…)也可以将某些数据结构转为数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; arguments 对象</span><br><span class="line">function foo() &#123;</span><br><span class="line">　　var args &#x3D; [...arguments];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; NodeList 对象</span><br><span class="line">[...document.querySelectorAll(&#39;div&#39;)]</span><br></pre></td></tr></table></figure>

<h3 id="2-Array-of"><a href="#2-Array-of" class="headerlink" title="2. Array.of()"></a>2. Array.of()</h3><p>Array.of 方法用于将一组值，转换为数组。Array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。<br>Array.of 基本上可以用来替代 Array()或 new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。<br>这个方法的主要目的，是弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array() &#x2F;&#x2F; []</span><br><span class="line">Array(3) &#x2F;&#x2F; [, , ,]</span><br><span class="line">Array(3, 11, 8) &#x2F;&#x2F; [3, 11, 8]</span><br><span class="line"></span><br><span class="line">Array.of() &#x2F;&#x2F; []</span><br><span class="line">Array.of(3) &#x2F;&#x2F; [3]</span><br><span class="line">Array.of(3, 11, 8) &#x2F;&#x2F; [3,11,8]</span><br><span class="line"></span><br><span class="line">Array.of(3).length &#x2F;&#x2F; 1</span><br><span class="line">Array.of(undefined) &#x2F;&#x2F; [undefined]</span><br><span class="line">Array.of(1) &#x2F;&#x2F; [1]</span><br><span class="line">Array.of(1, 2) &#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure>

<h3 id="3-find-和-findIndex"><a href="#3-find-和-findIndex" class="headerlink" title="3. find() 和 findIndex()"></a>3. find() 和 findIndex()</h3><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) &#x3D;&gt; n &lt; 0)</span><br><span class="line">&#x2F;&#x2F; -5</span><br><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line">    return value &gt; 9;</span><br><span class="line">&#125;) &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<p>上面代码中，find 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。<br>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">    return value &gt; 9;</span><br><span class="line">&#125;) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h3 id="4-fill"><a href="#4-fill" class="headerlink" title="4. fill()"></a>4. fill()</h3><p>fill()方法使用给定值，填充一个数组。数组中已有的元素，会被全部抹去。可以接受三个参数，指定要填充的值，指定填充的起始位置和结束位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)</span><br><span class="line">&#x2F;&#x2F; [7, 7, 7]</span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">&#x2F;&#x2F; [7, 7, 7]</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)</span><br><span class="line">&#x2F;&#x2F; [&#39;a&#39;, 7, &#39;c&#39;]</span><br></pre></td></tr></table></figure>

<h3 id="5-entries-，-keys-和-values"><a href="#5-entries-，-keys-和-values" class="headerlink" title="5. entries() ， keys() 和 values()"></a>5. entries() ， keys() 和 values()</h3><p>entries()，keys()和 values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;</span><br><span class="line">    console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;</span><br><span class="line">    console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;b&#39;</span><br><span class="line">for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;</span><br><span class="line">    console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 &quot;a&quot;</span><br><span class="line">&#x2F;&#x2F; 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>

<h3 id="6-includes"><a href="#6-includes" class="headerlink" title="6. includes()"></a>6. includes()</h3><p>ES5 中，我们常用数组的 indexOf 方法，检查是否包含某个值。indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于 -1 ，表达起来不够直观。二是，它内部使用严格相当运算符（ === ）进行判断，这会导致对 NaN 的误判。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">&#x2F;&#x2F; -1</span><br><span class="line">includes使用的是不一样的判断算法，就没有这个问题。</span><br><span class="line">[NaN].includes(NaN)</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>类似的是 ES7 中 Array.prototype.includes 方法，它返回一个布尔值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].includes(2); &#x2F;&#x2F; true</span><br><span class="line">[1, 2, 3].includes(4); &#x2F;&#x2F; false</span><br><span class="line">[1, 2, NaN].includes(NaN); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>该方法的第二个参数表示搜索的起始位置，默认为 0 。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4 ，但数组长度为 3 ），则会重置为从 0 开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3); &#x2F;&#x2F; false</span><br><span class="line">[1, 2, 3].includes(3, -1); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>另外， Map 和 Set 数据结构有一个 has 方法，需要注意与 includes 区分。<br>Map 结构的 has 方法，是用来查找键名的，比如 Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。<br>Set 结构的 has 方法，是用来查找值的，比如 Set.prototype.has(value)、WeakSet.prototype.has(value)。</p>
<h3 id="7-数组的空位"><a href="#7-数组的空位" class="headerlink" title="7. 数组的空位"></a>7. 数组的空位</h3><ul>
<li><strong>ES5 对空位的处理,大多数情况下会忽略空位。</strong><br>forEach() , filter() , every() 和 some()都会跳过空位。<br>map()会跳过空位，但会保留这个值<br>join()和 toString()会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; forEach方法</span><br><span class="line">[,&#39;a&#39;].forEach((x,i) &#x3D;&gt; console.log(i)); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; filter方法</span><br><span class="line">[&#39;a&#39;,,&#39;b&#39;].filter(x &#x3D;&gt; true) &#x2F;&#x2F; [&#39;a&#39;,&#39;b&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; every方法</span><br><span class="line">[,&#39;a&#39;].every(x &#x3D;&gt; x&#x3D;&#x3D;&#x3D;&#39;a&#39;) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; some方法</span><br><span class="line">[,&#39;a&#39;].some(x &#x3D;&gt; x !&#x3D;&#x3D; &#39;a&#39;) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; map方法</span><br><span class="line">[,&#39;a&#39;].map(x &#x3D;&gt; 1) &#x2F;&#x2F; [,1]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; join方法</span><br><span class="line">[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) &#x2F;&#x2F; &quot;#a##&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; toString方法</span><br><span class="line">[,&#39;a&#39;,undefined,null].toString() &#x2F;&#x2F; &quot;,a,,&quot;</span><br></pre></td></tr></table></figure>

<p><strong>ES6 则是明确将空位转为 undefined。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</span><br><span class="line">Array.from([&#39;a&#39;,,&#39;b&#39;])  &#x2F;&#x2F; [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩展运算符（...）也会将空位转为undefined。</span><br><span class="line">[...[&#39;a&#39;,,&#39;b&#39;]]  &#x2F;&#x2F; [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;copyWithin()会连空位一起拷贝。</span><br><span class="line">[,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) &#x2F;&#x2F; [,&quot;a&quot;,,&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;fill()会将空位视为正常的数组位置。</span><br><span class="line">new Array(3).fill(&#39;a&#39;) &#x2F;&#x2F; [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;for...of循环也会遍历空位。</span><br><span class="line">let arr &#x3D; [, ,];</span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F;上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</span><br><span class="line">&#x2F;&#x2F; entries()</span><br><span class="line">[...[,&#39;a&#39;].entries()] &#x2F;&#x2F; [[0,undefined], [1,&quot;a&quot;]]</span><br><span class="line">&#x2F;&#x2F; keys()</span><br><span class="line">[...[,&#39;a&#39;].keys()] &#x2F;&#x2F; [0,1]</span><br><span class="line">&#x2F;&#x2F; values()</span><br><span class="line">[...[,&#39;a&#39;].values()] &#x2F;&#x2F; [undefined,&quot;a&quot;]</span><br><span class="line">&#x2F;&#x2F; find()</span><br><span class="line">[,&#39;a&#39;].find(x &#x3D;&gt; true) &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; findIndex()</span><br><span class="line">[,&#39;a&#39;].findIndex(x &#x3D;&gt; true) &#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F;由于空位的处理规则非常不统一，所以建议避免出现空位。</span><br></pre></td></tr></table></figure>

<p>##参考 <a href="https://www.cnblogs.com/guorange/p/7450145.html">https://www.cnblogs.com/guorange/p/7450145.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>css速查表</title>
    <url>/2021/04/11/css%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>c3 参考手册 <a href="https://www.xp.cn/css3/">https://www.xp.cn/css3/</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm一些指令</title>
    <url>/2021/04/11/nvm%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>nvm list 是查找本电脑上所有的 node 版本</p>
<ul>
<li>nvm list 查看已经安装的版本</li>
<li>nvm list installed 查看已经安装的版本</li>
<li>nvm list available 查看网络可以安装的版本</li>
</ul>
<p>nvm install 安装最新版本 nvm</p>
<p>nvm use <version> ## 切换使用指定的版本 node</p>
<p>nvm ls 列出所有版本</p>
<p>nvm current 显示当前版本</p>
<p>nvm alias <name> <version> ## 给不同的版本号添加别名</p>
<p>nvm unalias <name> ## 删除已定义的别名</p>
<p>nvm reinstall-packages <version> ## 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</p>
<p>nvm on 打开 nodejs 控制</p>
<p>nvm off 关闭 nodejs 控制</p>
<p>nvm proxy 查看设置与代理</p>
<p>nvm node_mirror [url] 设置或者查看 setting.txt 中的 node_mirror，如果不设置的默认是 <a href="https://nodejs.org/dist/">https://nodejs.org/dist/</a><br>　　 nvm npm_mirror [url] 设置或者查看 setting.txt 中的 npm_mirror,如果不设置的话默认的是： <a href="https://github.com/npm/npm/archive/">https://github.com/npm/npm/archive/</a>.</p>
<p>nvm uninstall <version> 卸载制定的版本</p>
<p>nvm use [version] [arch] 切换制定的 node 版本和位数</p>
<p>nvm root [path] 设置和查看 root 路径</p>
<p>nvm version 查看当前的版本</p>
]]></content>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>vue swiper问题</title>
    <url>/2021/04/11/swiper%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E6%97%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://blog.csdn.net/front_endxiaobaia/article/details/105206691">https://blog.csdn.net/front_endxiaobaia/article/details/105206691</a></p>
]]></content>
      <categories>
        <category>插件</category>
        <category>swiper</category>
      </categories>
      <tags>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router报错</title>
    <url>/2021/04/11/vue-router%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="重复点击导航时，控制台出现不影响功能的报错"><a href="#重复点击导航时，控制台出现不影响功能的报错" class="headerlink" title="重复点击导航时，控制台出现不影响功能的报错~~"></a>重复点击导航时，控制台出现不影响功能的报错~~</h1><p>错误贴个图<br><img src="https://img2020.cnblogs.com/blog/2304151/202103/2304151-20210310014250607-645824452.png" alt="vue-router"></p>
<p><strong>解决</strong></p>
<ul>
<li><p>方案一： router.js 文件中添加如下代码<br><img src="https://img2020.cnblogs.com/blog/2304151/202103/2304151-20210310014950447-330606213.png" alt="solve1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重复点击导航时，控制台出现不影响功能的报错</span><br><span class="line">const VueRouterPush &#x3D; Router.prototype.push;</span><br><span class="line">Router.prototype.push &#x3D; function push(to) &#123;</span><br><span class="line">  return VueRouterPush.call(this, to).catch(err &#x3D;&gt; err);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>方案二： 在跳转时，判断以下当前路由与跳转的路由是否一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toMenu (item) &#123;</span><br><span class="line">if (this.$route.path !&#x3D;&#x3D; item.url) &#123;</span><br><span class="line">  this.$router.push(&#123; path: item.url &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方案三： 使用 catch 方法捕获 router.push 异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$router.push(route).catch(err &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;输出报错&#39;,err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>vue swiper5</title>
    <url>/2021/04/11/swiper5%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://img2020.cnblogs.com/blog/2304151/202102/2304151-20210214155707221-403777173.png" alt="swiper"></p>
<p>swiper6 和 swiper5 所需文件所在目录不一样。（懒得截屏说明了，有兴趣的小伙伴可以去试试，图仅展示两个版本的区别）。</p>
<p>本次使用 vs cod 中 install <a href="mailto:&#x73;&#119;&#105;&#x70;&#101;&#x72;&#x40;&#53;&#46;&#52;&#46;&#53;">&#x73;&#119;&#105;&#x70;&#101;&#x72;&#x40;&#53;&#46;&#52;&#46;&#53;</a>，会按照 swiper6 的目录去找文件，会报找不到某个文件的 error。</p>
]]></content>
      <categories>
        <category>插件</category>
        <category>swiper</category>
      </categories>
      <tags>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title>使用better-scroll</title>
    <url>/2021/04/11/%E4%BD%BF%E7%94%A8better-scroll%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基本使用略过！！！</p>
<p>使用$nextTick()可以将 better-scroll（以下简称 BS）延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">                    var scroll &#x3D; new BScroll(this.$refs.movie_body , &#123;</span><br><span class="line">                        &#x2F;&#x2F; pullUpLoad: true,</span><br><span class="line">                        &#x2F;&#x2F; scrollbar: true,</span><br><span class="line">                        &#x2F;&#x2F; pullDownRefresh: true,</span><br><span class="line">                        click: true,</span><br><span class="line">                        probeType: 1</span><br><span class="line">                    &#125;)</span><br></pre></td></tr></table></figure>

<p><em>重点是在于要是多个页面中使用到 BS 呢？封装成一个组件之后遇到刷新后无法滚动的问题。</em></p>
<p><em>将 BS 封装为组件的 DOM 结构，slot 里分发的内容其实是 ul</em><br><img src="https://img2020.cnblogs.com/blog/2304151/202103/2304151-20210303230419241-1758805160.png" alt="img1"></p>
<p><em>Chrome 渲染的结构</em><br><img src="https://img2020.cnblogs.com/blog/2304151/202103/2304151-20210303230347378-162691737.png" alt="img2"></p>
<p>上图，DOM 的确已经出现了 css 样式，但是仍旧不滚动。<br>参考了许多帖子仍旧未解决我的问题，其实我也有了一些猜测，可能是类似 swiper 初始化过早的问题，然后添加延时成功解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted()&#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        var scroll &#x3D; new BScroll( this.$refs.wrapper, &#123;</span><br><span class="line">                click: true,</span><br><span class="line">                probeType: 1,</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; scroll.on(&#39;scroll&#39;,(pos) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;     this.handleToScroll(pos)</span><br><span class="line">        &#x2F;&#x2F; &#125;);</span><br><span class="line">        &#x2F;&#x2F; scroll.on(&#39;touchEnd&#39;,(pos) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;     this.handleToTouchEnd(pos)</span><br><span class="line">        &#x2F;&#x2F; &#125;)</span><br><span class="line">        &#125;,500)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>插件</category>
        <category>better-scroll</category>
      </categories>
      <tags>
        <tag>better-scroll</tag>
      </tags>
  </entry>
  <entry>
    <title>vue mixin</title>
    <url>/2021/04/20/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/mixin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</strong></p>
<h4 id="混入选项的合并"><a href="#混入选项的合并" class="headerlink" title="混入选项的合并"></a>混入选项的合并</h4><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<blockquote>
<p>data 混入<br>data 混入会在被混入组件内 data 进行递归合并，并在命名冲突是以被混入数据优先。</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var mixin = &#123;</span><br><span class="line">  dat<span class="variable">a:</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">      foo: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixin<span class="variable">s:</span> [mixin],</span><br><span class="line">  dat<span class="variable">a:</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;goodbye&#x27;</span>,</span><br><span class="line">      bar: <span class="string">&#x27;def&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(this.$data)</span><br><span class="line">    // =&gt; &#123; message: <span class="string">&quot;goodbye&quot;</span>, foo: <span class="string">&quot;abc&quot;</span>, bar: <span class="string">&quot;def&quot;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>钩子混入<br>对于 created,mounted 等钩子来说，被混入的组件会将同名钩子合并为一个数组，它们都会被调用，混入的钩子先调用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;混入对象的钩子被调用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;组件钩子被调用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; &quot;混入对象的钩子被调用&quot;</span></span><br><span class="line"><span class="comment">// =&gt; &quot;组件钩子被调用&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 methods，computed 等其他选项类似于 data 的混入，被合并为一个对象，存在命名冲突已被混入的组件原命名为准</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var mixin = &#123;</span><br><span class="line">  method<span class="variable">s:</span> &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflictin<span class="variable">g:</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&#x27;from mixin&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixin<span class="variable">s:</span> [mixin],</span><br><span class="line">  method<span class="variable">s:</span> &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    conflictin<span class="variable">g:</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&#x27;from self&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">vm</span>.foo() // =&gt; <span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">vm</span>.bar() // =&gt; <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="keyword">vm</span>.conflicting() // =&gt; <span class="string">&quot;from self&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><p><strong>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 为自定义的选项 <span class="string">&#x27;myOption&#x27;</span> 注入一个处理器。</span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="keyword">function</span> () &#123;</span><br><span class="line">    var myOption = this.<span class="variable">$options</span>.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      console.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  myOption: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="regexp">//</span> =&gt; <span class="string">&quot;hello!&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h4><p>暂时没有使用过这样的场景，目前使用到混入的没有涉及</p>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自定义指令</title>
    <url>/2021/04/20/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="自定义指令注册及使用"><a href="#自定义指令注册及使用" class="headerlink" title="自定义指令注册及使用"></a>自定义指令注册及使用</h3><blockquote>
<p>全局注册</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 注册一个全局自定义指令 `v-focus`</span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="regexp">//</span> 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: <span class="keyword">function</span> (el) &#123;</span><br><span class="line">    <span class="regexp">//</span> 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>局部注册</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">directive<span class="variable">s:</span> &#123;</span><br><span class="line">  focu<span class="variable">s:</span> &#123;</span><br><span class="line">    // 指令的定义</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> &#123;</span></span><br><span class="line">      <span class="keyword">el</span>.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用自定义指令</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;input v-focus&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义指令钩子-均为可选"><a href="#自定义指令钩子-均为可选" class="headerlink" title="自定义指令钩子(均为可选)"></a>自定义指令钩子(均为可选)</h3><ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</li>
<li>inserted：被绑定元素插入父节点时调用 (父节点存在，但不一定已被插入文档中)</li>
<li>update：所在组件的 VNode 更新时调用</li>
<li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用</li>
<li>unbind：只调用一次，指令与元素解绑时调用</li>
</ul>
<h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4><ul>
<li><p>el：指令所绑定的元素，可以用来直接操作 DOM。</p>
</li>
<li><p>binding：一个对象，包含以下 property</p>
<ul>
<li>name：指令名，不包括 v- 前缀。</li>
<li>value：指令的绑定值. v-focus=”1+1” 中，绑定值为 2 ; 绑定多个值，写为对象字面量 {a:1,b:2}。value 可以接受合法的任何 js 表达式。可以</li>
<li>expression：字符串形式的指令表达式. v-focus=”1+1” 中，表达式为 1+1</li>
<li>arg：传给指令的参数，可选。 v-focus:a ，参数为 a , 也可以使用动态参数 v-focus:[a]</li>
<li>modifiers：一个包含修饰符的对象。 v-focus:a.b 修饰符对象为 {a:true,b:false}</li>
<li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>
</ul>
</li>
<li><p>vnode：Vue 编译生成的虚拟节点。</p>
</li>
<li><p>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p>
</li>
</ul>
<p><strong>动态参数的一个例子</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">&quot;dynamicexample&quot;</span>&gt;</span><br><span class="line">  &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt;</span><br><span class="line">  &lt;p v-pin:[direction]=<span class="string">&quot;200&quot;</span>&gt;I am pinned <span class="keyword">onto</span> <span class="keyword">the</span> page <span class="keyword">at</span> <span class="number">200</span>px <span class="keyword">to</span> <span class="keyword">the</span> left.&lt;/p&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;pin&#x27;</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> <span class="params">(el, binding, vnode)</span> &#123;</span></span><br><span class="line">    <span class="keyword">el</span>.style.position = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">    var s = (binding.arg == <span class="string">&#x27;left&#x27;</span> ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">    <span class="keyword">el</span>.style[s] = binding.value + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span> <span class="string">&#x27;#dynamicexample&#x27;</span>,</span><br><span class="line">  dat<span class="variable">a:</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      direction: <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>filter</title>
    <url>/2021/04/20/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="过滤器使用"><a href="#过滤器使用" class="headerlink" title="过滤器使用"></a>过滤器使用</h3><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span></span><br><span class="line"><span class="template-variable">&#123;&#123; <span class="name">message</span> | filter1 &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 过滤器可以串联 --&gt;</span></span></span><br><span class="line"><span class="template-variable">&#123;&#123; <span class="name">message</span> | filter1 | filter2 &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | filter1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="局部过滤"><a href="#局部过滤" class="headerlink" title="局部过滤"></a>局部过滤</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span><span class="variable">s:</span> &#123;</span><br><span class="line">  filter1: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter2: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局过滤"><a href="#全局过滤" class="headerlink" title="全局过滤"></a>全局过滤</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;filter1&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>存在全局和局部过滤器命名冲突，优先使用局部过滤器</strong></p>
<h3 id="过滤器参数"><a href="#过滤器参数" class="headerlink" title="过滤器参数"></a>过滤器参数</h3><blockquote>
<p>第一个参数</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>html</span><br><span class="line">&#123;&#123; message | filter1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>js</span><br><span class="line">filters:&#123;</span><br><span class="line">  filter1(arg)&#123;</span><br><span class="line">    <span class="regexp">//</span>arg就是message本身</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二个参数</p>
</blockquote>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml">//html</span></span><br><span class="line"><span class="template-variable">&#123;&#123; <span class="name">message</span> | filter1(<span class="name">arg1</span>) &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">//js</span></span><br><span class="line"><span class="xml">filters:&#123;</span></span><br><span class="line"><span class="xml">  filter1(arg,arg1)&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第三个参数</p>
</blockquote>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml">//html</span></span><br><span class="line"><span class="template-variable">&#123;&#123; <span class="name">message</span> | filter1(<span class="name">arg1</span>,arg2) &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">//js</span></span><br><span class="line"><span class="xml">filters:&#123;</span></span><br><span class="line"><span class="xml">  filter1(arg,arg1,arg2)&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>vue3 移除了过滤器官方给出的解释是</p>
<blockquote>
<p>尽管这似乎很方便，但是它需要一种自定义语法，该语法打破了花括号内的表达式只是“ JavaScript”的假设，这既有学习成本，也有实现成本。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JS常用方法整理</title>
    <url>/2021/04/11/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Array"><a href="#Array" class="headerlink" title="Array:"></a>Array:</h3><p>slice(start,end) 从索引为 start 的开始取，取到索引为 end 的为止，end 的取不到, 如果 end 为负数，表示索引为数组的长度+负数.<br>toString() 把数组转换成字符串，每一项用,分割<br>valueOf() 返回数组对象本身</p>
<p>indexOf()从数组开头开始获取<br>lastIndexof()从数组末尾开始获取<br>获取数组中某元素的索引(位置) 如果要检索的数组值没有出现，则该方法返回 -1。</p>
<p>push() 添加到数组的最后面<br>pop() 删除数组中的最后一个<br>shift() 删除数组中的最前一个<br>unshift() 添加到数组的最前面<br>reverse() 将数组中的元素进行反转，倒序显示<br>sort() 将数组元素进行排序<br>filter() 返回 true 的留下，false 的舍弃<br>forEach() 循环遍历里面的每一个元素<br>array.splice(0,arr.length); 删除数组中所有项目<br>join() 将数组中的元素连接成字符串输出<br>concat() 连接两个数组<br>slice() 从当前数组中截取一个新的数组，不影响原来的数组，参数 start 从 0 开始,end 从 1 开始,end 截取不到。<br>splice() 删除或替换当前数组的某些项目，参数 start,deleteCount,options(要替换的项目),</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>获取字符串中字符的索引: 如果要检索的字符串值没有出现，则该方法返回 -1。<br>indexOf() 返回指定内容在元字符串中的位置<br>lastIndexOf() 从后往前找，只找第一个匹配的</p>
<p>trim() 只能去除字符串前后的空白<br>字符串.toUpperCase() 字符串转成大写<br>字符串.toLowerCase() 字符串转成小写<br>concat() 拼接字符串，等效于+，+更常用<br>slice() 从 start 位置开始，截取到 end 位置，end 取不到<br>substring() 从 start 位置开始，截取到 end 位置，end 取不到<br>substr() 从 start 位置开始，截取 length 个字符，只有一个就参数就截取到最后<br>replace() 替换字符串的某元素,并返回替换后的字符串<br>split() 将字符串分割(l 转换)成数组</p>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>本身就是一个对象, 不需要在通过构造函数去创建, 该对象中集合了很多关于数学运算的方法<br>Math.abs() 获取一个对象的绝对值<br>Math.round() 四舍五入<br>Math.PI π<br>Math.max() 求几个数的最大数<br>Math.min() 求几个数的最小数<br>Math.ceil() 向上取整<br>Math.floor() 向下取整<br>Math.random() 随机数 (随机生成 0 ~1 之间的数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.floor(Math.random()*10) &#x2F;&#x2F; 获取随机生成 0 到 10之间的整数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue响应式原理</title>
    <url>/2021/04/20/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。<br>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<p>参考一篇言简意赅的关于响应式的文章<br><a href="https://www.cnblogs.com/zhenfei-jiang/p/7542900.html">https://www.cnblogs.com/zhenfei-jiang/p/7542900.html</a></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>对于对象<blockquote>
<p>Vue 无法检测 property 的添加或移除。Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>a:</span><span class="template-variable">&#123;&#123;<span class="name">msg.a</span>&#125;&#125;</span><span class="xml"> <span class="tag">&lt;<span class="name">br</span> /&gt;</span>b: </span><span class="template-variable">&#123;&#123;<span class="name">msg.b</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">new Vue(&#123;</span></span><br><span class="line"><span class="xml">  el: &#x27;#app&#x27;</span></span><br><span class="line"><span class="xml">  data: &#123;</span></span><br><span class="line"><span class="xml">    msg:&#123;</span></span><br><span class="line"><span class="xml">      a:1</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--</span></span></span><br><span class="line"><span class="xml">浏览器控制台输入以下代码可以获取vue</span></span><br><span class="line"><span class="xml">let vue = document.getElementById(&#x27;app&#x27;)._vue_</span></span><br><span class="line"><span class="xml">获取msg</span></span><br><span class="line"><span class="xml">let msg = vue._data</span></span><br><span class="line"><span class="xml"> --&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时输入 msg.a = 2 可以看到视图实时更新了。<br>输入 msg.b = 1，发现视图不渲染，但是打印 msg 可以看到数据是更新了的。</p>
<p>对于此种现象，可以使使用 Vue.set()或 vm.$set(),实现响应式。vm.$set(msg,’b’,1)，实现了响应式<br>还可以使用 Object.assign({},msg,{b:1}),同样可以实现响应式</p>
<ul>
<li>对于数组</li>
</ul>
<p>Vue 不能检测以下数组的变动：</p>
<blockquote>
<p>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br>当你修改数组的长度时，例如：vm.items.length = newLength</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: <span class="selector-attr">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm<span class="selector-class">.items</span><span class="selector-attr">[1]</span> = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm<span class="selector-class">.items</span><span class="selector-class">.length</span> = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<p>同理可以这么做<br>Vue.set(vm.items, indexOfItem, newValue)<br>vm.items.splice(newLength)</p>
<h3 id="声明响应式"><a href="#声明响应式" class="headerlink" title="声明响应式"></a>声明响应式</h3><p>由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> vm = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    <span class="comment">// 声明 message 为一个空值字符串</span></span><br><span class="line">    message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 之后设置 `message`</span></span><br><span class="line">vm.message = <span class="string">&#x27;Hello!&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue数组更新的检测</title>
    <url>/2021/04/21/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/vue%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E7%9A%84%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>可以触发数组视图更新</p>
<ul>
<li>变更原数组<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>返回新数组<ul>
<li>filter()</li>
<li>concat()</li>
<li>slice()</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>不能触发视图更新–通过索引变更<br>arr.[0] = newVal</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>修饰符</title>
    <url>/2021/04/21/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul>
<li>.stop 阻止冒泡（通俗讲就是阻止事件向上级 DOM 元素传递）</li>
<li>.prevent 阻止默认事件的发生</li>
<li>.capture 捕获冒泡，即有冒泡发生时，有该修饰符的 dom 元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//html</span></span><br><span class="line">&lt;div <span class="meta">@click</span>.capture=<span class="string">&quot;outClick&quot;</span>&gt;</span><br><span class="line">  &lt;div <span class="meta">@click</span>=<span class="string">&quot;innerClick&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="meta">@click</span>=<span class="string">&quot;mostInnerClick&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//js</span></span><br><span class="line">methods:&#123;</span><br><span class="line">  <span class="function"><span class="title">outClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;outClick&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">innerClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;innerClick&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mostInnerClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mostInnerClick&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--</span><br><span class="line">点击最内层的div</span><br><span class="line">打印顺序：outClick =&gt; <span class="function"><span class="params">mostInnerClick</span> =&gt;</span> innerClick</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>.self 将事件绑定到自身，只有自身才能触发，通常用于避免冒泡事件的影响</li>
<li>.once 设置事件只能触发一次，比如按钮的点击等。</li>
<li>.passive 该修饰符大概意思用于对 DOM 的默认事件进行性能优化，根据官网的例子比如超出最大范围的滚动条滚动的</li>
</ul>
<h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p><a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6</a></p>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>props</title>
    <url>/2021/04/21/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/props/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="props-基本使用"><a href="#props-基本使用" class="headerlink" title="props 基本使用"></a>props 基本使用</h3><ul>
<li>Prop 的大小写<br>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">&#x27;app&#x27;</span>&gt;</span><br><span class="line">  &lt;child pass-msg=<span class="string">&#x27;hello&#x27;</span>&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    variable: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">    arr: <span class="selector-attr">[1,2,3]</span>,</span><br><span class="line">    obj: &#123;</span><br><span class="line">      <span class="selector-tag">a</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件中,</span></span><br><span class="line">props:<span class="selector-attr">[<span class="string">&#x27;passMsg&#x27;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a>传递静态或动态 Prop</h4><ul>
<li>prop 传入一个静态的值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">pass-msg</span>=<span class="string">&#x27;hello&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>动态赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入变量</span></span><br><span class="line">&lt;child :pass-msg=<span class="string">&#x27;variable&#x27;</span>&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入Number</span></span><br><span class="line">&lt;child :pass-msg=<span class="string">&#x27;1&#x27;</span>&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入Boolean</span></span><br><span class="line">&lt;child :pass-msg=<span class="string">&#x27;true&#x27;</span>&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入Array</span></span><br><span class="line">&lt;child :pass-msg=<span class="string">&#x27;arr&#x27;</span>&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入Object</span></span><br><span class="line">&lt;child :pass-msg=<span class="string">&#x27;obj&#x27;</span>&gt;&lt;/child&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>遵守父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</p>
<p>如需变更子组件应该将数据初始化为自己的数据后再进行操作</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件中</span></span><br><span class="line">props: [<span class="string">&#x27;passMsg&#x27;</span>],</span><br><span class="line"><span class="keyword">data</span>: function () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    passMsg: <span class="keyword">this</span>.passMsg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是引用数据类型，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。比如对象或数组，在子组件中改变了，也是会使得父组件的数据改变，它们本质上都是引用栈中的地址，若本身想改变又不影响父组件，应该克隆一份</strong></p>
<h4 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>子组件中</span><br><span class="line">props： &#123;</span><br><span class="line">  //msg1接受<span class="built_in">Number</span>类型</span><br><span class="line">  msg1: <span class="built_in">Number</span>, <span class="regexp">//</span><span class="string">&#x27;string&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  //msg2接受<span class="built_in">Number</span>或<span class="built_in">String</span>类型</span><br><span class="line">  msg2: [<span class="built_in">Number</span>,<span class="built_in">String</span>],</span><br><span class="line"></span><br><span class="line">  //msg3接受<span class="built_in">Boolean</span>类型，默认值为<span class="literal">true</span></span><br><span class="line">  msg3: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    default: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  //msg4接受<span class="built_in">Array</span>类型，必须传入</span><br><span class="line">  msg4: &#123;</span><br><span class="line">    type:<span class="built_in">Array</span>,</span><br><span class="line">    require:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="regexp">//</span>当数组默认值为空对象时,必须<span class="keyword">return</span>一个空数组，对象也一样</span><br><span class="line">  msg5: &#123;</span><br><span class="line">    type: <span class="built_in">Array</span>,</span><br><span class="line">    default: <span class="function"><span class="params">()</span>=&gt;</span> []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p>
<h5 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h5><ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Date</li>
<li>Function</li>
<li>Symbol</li>
</ul>
<h3 id="inheritAttrs-与-attrs"><a href="#inheritAttrs-与-attrs" class="headerlink" title="inheritAttrs 与 $attrs"></a>inheritAttrs 与 $attrs</h3><h4 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h4><p>inheritAttrs 默认为 true，允许继承的意思</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">class</span>=<span class="string">&#x27;mychild&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;mychild&#x27;</span> <span class="attr">msg</span>=<span class="string">&#x27;hello&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//子组件模板</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&#x27;label&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;label&#x27;</span>&gt;</span> //label是子组件的根元素</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//子组件没有接受msg</span><br><span class="line">props:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 那么在html会渲染msg为在子组件的根元素上,并且已有的属性会被覆盖掉,但是对于class和style会智能一些，合并起来</span></span><br><span class="line"><span class="comment">&lt;label class=&#x27;label mychild&#x27; type=&#x27;mychild&#x27; msg=&#x27;hello&#x27;&gt;...&lt;/label&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">若不想把这些非法的属性渲染到根元素，只需要设置inheritAttrs: false</span><br></pre></td></tr></table></figure>

<h4 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h4><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml">//父组件</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">son</span> <span class="attr">a</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">b</span>=<span class="string">&#x27;2&#x27;</span> <span class="attr">c</span>=<span class="string">&#x27;3&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//子组件</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    //此时$attrs为一个对象，&#123;b:&#x27;2&#x27;,c=&#x27;3&#x27;&#125;，除class、style、props接受了的属性</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">grandson</span> <span class="attr">v-bind</span>=<span class="string">&#x27;$attrs&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">grandson</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//子组件接受了父组件传来的a</span></span><br><span class="line"><span class="xml">props:[a],</span></span><br><span class="line"><span class="xml">inheritAttrs: false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">//孙组件,可以实现跨组件传值，避免每跨一层，每层都需要写props</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123;<span class="name">b</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123;<span class="name">c</span>&#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue自定义事件</title>
    <url>/2021/04/21/vue%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</strong></p>
<p>官方推荐始终使用 kebab-case 命名</p>
<h3 id="sync"><a href="#sync" class="headerlink" title=".sync"></a>.sync</h3><p>vue 中我们经常会给子组件添加自定义事件，监听子组件某个状态的改变</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>父组件给子组件传入一个函数</span><br><span class="line"> &lt;child :age=<span class="string">&quot;age&quot;</span> @setAge=<span class="string">&quot;(res)=&gt; age = res&quot;</span>&gt;</span><br><span class="line"> &lt;/child&gt;</span><br><span class="line"> <span class="regexp">//</span>子组件通过调用这个函数来实现修改父组件的状态。</span><br><span class="line"> mounted () &#123;</span><br><span class="line">      console.log(this.<span class="variable">$emit</span>(<span class="string">&#x27;setAge&#x27;</span>,<span class="number">1234567</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种情况比较常见切写法比较复杂。使用.sync 可以达到简化</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>父组件将age传给子组件并使用.sync修饰符。</span><br><span class="line">&lt;child :age.sync=<span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line">&lt;/child&gt;</span><br><span class="line"><span class="regexp">//</span>子组件触发事件</span><br><span class="line"> mounted () &#123;</span><br><span class="line">    console.log(this.<span class="variable">$emit</span>(<span class="string">&#x27;update:age&#x27;</span>,<span class="number">1234567</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是事件名称被修改成了 update:age</strong></p>
<ul>
<li>updata：是 vue 为我们约定好的名称部分</li>
<li>age: 是我们要修改的状态</li>
</ul>
<p>参考官方文档 <a href="https://cn.vuejs.org/v2/guide/components-custom-events.html">https://cn.vuejs.org/v2/guide/components-custom-events.html</a><br>参考一篇写的非常不错的，短小精悍的文章 <a href="https://blog.csdn.net/liushijun_/article/details/92426854">https://blog.csdn.net/liushijun_/article/details/92426854</a></p>
<h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。<br>简单点讲它是一个对象，里面包含了作用在这个组件上所有的监听器（监听事件），可以通过 v-on=”$listeners” 将事件监听指向这个组件内的子元素（包括内部的子组件）。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &lt;child1</span></span><br><span class="line"><span class="xml">        v-on:test1=&quot;onTest1&quot;</span></span><br><span class="line"><span class="xml">        v-on:test2=&quot;onTest2&quot;&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">child1</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  Vue.component(&quot;Child1&quot;, </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    inheritAttrs:<span class="built_in"> true</span>,</span></span><br><span class="line"><span class="xquery">    template: `</span></span><br><span class="line"><span class="xquery">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-1&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">child2</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child2</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">    &lt;/div&gt;`,</span></span><br><span class="line"><span class="xquery">    mounted: <span class="keyword">function</span>() &#123;</span></span><br><span class="line"><span class="xquery">      this.<span class="variable">$emit</span>(<span class="string">&quot;test1&quot;</span>);</span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">  Vue.component(&quot;Child2&quot;, </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    template: `</span></span><br><span class="line"><span class="xquery">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-2&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;test2&#x27;,&#x27;按钮点击&#x27;)&quot;</span>&gt;</span>触发事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="xquery">    &lt;/div&gt;`,</span></span><br><span class="line"><span class="xquery">    mounted: <span class="keyword">function</span>() &#123;</span></span><br><span class="line"><span class="xquery">      this.<span class="variable">$emit</span>(<span class="string">&quot;test2&quot;</span>);</span></span><br><span class="line"><span class="xquery">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml">  const app = new Vue(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="xquery">    methods: &#123;</span></span><br><span class="line"><span class="xquery">      onTest1() &#123;</span></span><br><span class="line"><span class="xquery">        console.log(<span class="string">&quot;test1 running...&quot;</span>);</span></span><br><span class="line"><span class="xquery">      &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">      onTest2(value) </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">        console.log(<span class="string">&quot;test2 running...&quot;</span> + <span class="keyword">value</span>);</span></span><br><span class="line"><span class="xquery">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
        <category>vue学习笔记</category>
      </categories>
      <tags>
        <tag>vue学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值</title>
    <url>/2021/04/21/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="基本数据类型的结构赋值"><a href="#基本数据类型的结构赋值" class="headerlink" title="基本数据类型的结构赋值"></a>基本数据类型的结构赋值</h3><h4 id="字符串结构赋值"><a href="#字符串结构赋值" class="headerlink" title="字符串结构赋值"></a>字符串结构赋值</h4><p>转换成类型数组的结构</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line"><span class="attr">s</span> === Number.prototype.<span class="built_in">toString</span> // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="attr">s</span> === Boolean.prototype.<span class="built_in">toString</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="引用数据类型的结构赋值"><a href="#引用数据类型的结构赋值" class="headerlink" title="引用数据类型的结构赋值"></a>引用数据类型的结构赋值</h3><h4 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h4><p>数组的元素是按次序排列的，所以结构赋值的变量需要对应</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">console.log(a,b,c) <span class="regexp">//</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">let [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="regexp">//</span> <span class="string">&quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line">如果结构不成功为 undefined</span><br><span class="line">let [foo] = [];</span><br><span class="line">let [bar, foo] = [<span class="number">1</span>];</span><br><span class="line"><span class="regexp">//</span>foo 的值都为 undefined</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>不完全解构</span><br><span class="line">let [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">y <span class="regexp">//</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">b <span class="regexp">//</span> <span class="number">2</span></span><br><span class="line">d <span class="regexp">//</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>指定默认值</span><br><span class="line">let [foo = true] = [];</span><br><span class="line">foo <span class="regexp">//</span> true</span><br><span class="line"></span><br><span class="line">let [x, y] = [<span class="number">1</span>]</span><br><span class="line">console.log(x, y) <span class="regexp">//</span><span class="number">1</span>，undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h4><ul>
<li>对象的属性没有次序，变量必须与属性同名，才能取到正确的值</li>
<li>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let &#123; foo, bar &#125; = &#123; foo: <span class="string">&#x27;aaa&#x27;</span>, bar: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="regexp">//</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line">bar <span class="regexp">//</span> <span class="string">&quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</span><br><span class="line">const &#123; log &#125; = console;</span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>) <span class="regexp">//</span> hello</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>如果解构失败，变量的值等于 undefined。</span><br><span class="line">let &#123; baz &#125; = &#123; foo: <span class="string">&#x27;aaa&#x27;</span>, bar: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="regexp">//</span> undefined</span><br><span class="line"></span><br><span class="line">&lt;!-- 变量名与属性名不一致，必须写成下面这样</span><br><span class="line">foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 --&gt;</span><br><span class="line"></span><br><span class="line">let &#123; foo: baz &#125; = &#123; foo: <span class="string">&#x27;aaa&#x27;</span>, bar: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="regexp">//</span> <span class="string">&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;!-- 等价于 baz=&#123;foo: <span class="string">&#x27;aaa&#x27;</span>, bar: <span class="string">&#x27;bbb&#x27;</span>&#125;.foo --&gt;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>嵌套赋值</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line">(&#123; foo: obj.prop, bar: arr[<span class="number">0</span>] &#125; = &#123; foo: <span class="number">123</span>, bar: true &#125;);</span><br><span class="line">obj <span class="regexp">//</span> &#123;prop:<span class="number">123</span>&#125;</span><br><span class="line">arr <span class="regexp">//</span> [true]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</span><br><span class="line">let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>对象的解构赋值可以取到继承的属性。</span><br><span class="line">const obj1 = &#123;&#125;;</span><br><span class="line">const obj2 = &#123; foo: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">Object.setPrototypeOf(obj1, obj2); <span class="regexp">//</span>将 obj2 设置为 obj1 的原型对象</span><br><span class="line">const &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="regexp">//</span> <span class="string">&quot;bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>可以设置默认值</span><br><span class="line">var &#123;x = <span class="number">3</span>&#125; = &#123;&#125;; <span class="regexp">//</span>空对象，找不到可以赋值的属性，x 任取默认值</span><br><span class="line">x <span class="regexp">//</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">var &#123;x, y = <span class="number">5</span>&#125; = &#123;x: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">y <span class="regexp">//</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">var &#123;x: y = <span class="number">3</span>&#125; = &#123;x: <span class="number">5</span>&#125;; <span class="regexp">//</span>对象内有 x，将 x 赋给 y，覆盖掉 y 的默认值 x=<span class="number">3</span>,y=<span class="number">5</span>,y=x</span><br><span class="line">y <span class="regexp">//</span> <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="函数参数的结构赋值"><a href="#函数参数的结构赋值" class="headerlink" title="函数参数的结构赋值"></a>函数参数的结构赋值</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">add</span><span class="params">([x, y])</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].<span class="built_in">map</span>(([a, b]) =&gt; a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br><span class="line"></span><br><span class="line">&lt;!-- 函数参数的解构也可以使用默认值。</span><br><span class="line">函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 --&gt;</span><br><span class="line"><span class="function">function <span class="title">move</span><span class="params">(&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="built_in">move</span>(); <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是为函数move的参数指定默认值，而不是为变量x和y指定默认值</span></span><br><span class="line"><span class="function">function <span class="title">move</span><span class="params">(&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="built_in">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串新增方法</title>
    <url>/2021/04/21/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h4><p>ES5 有 String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于 0xFFFF 的字符。而 String.fromCodePoint()可以弥补它的不足</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">string</span> = <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CharCode(0x00061)</span> <span class="comment">//a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有多个参数则它们被合并成一个字符串返回</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>from<span class="constructor">CodePoint(0x78, 0x1f680, 0x79)</span><span class="operator"> === </span>&#x27;x\uD83D\uDE80y&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><blockquote>
<p><strong>codePointAt()</strong></p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var s = <span class="string">&quot;𠮷&quot;</span>;</span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.<span class="built_in">char</span><span class="constructor">At(0)</span> <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">s.<span class="built_in">char</span><span class="constructor">At(1)</span> <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">s.<span class="built_in">char</span><span class="constructor">CodeAt(0)</span> <span class="comment">// 55362</span></span><br><span class="line">s.<span class="built_in">char</span><span class="constructor">CodeAt(1)</span> <span class="comment">// 57271</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。</p>
<blockquote>
<p><strong>includes(str,start)</strong></p>
</blockquote>
<ul>
<li>str 查找的字符串</li>
<li>start 查找的起始位置</li>
</ul>
<p>JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中,es6 提供三种新方法，其中之一为 includes()</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="regexp">//</span> true</span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="regexp">//</span> false</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>startsWith(str,start)</strong> 返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</blockquote>
<ul>
<li>str 查找的字符串</li>
<li>start 查找的起始位置</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="regexp">//</span> true</span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="regexp">//</span> true</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>endsWith(str,inStart)</strong> 返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
</blockquote>
<ul>
<li>str 查找的字符串</li>
<li>inStart 在 inStart 位置内查找</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="regexp">//</span> true</span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="regexp">//</span> true      表示在前<span class="number">5</span>个字符内查找<span class="string">&#x27;Hello&#x27;</span>是不是最后位置</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>repeat(n)</strong> 返回一个新字符串，表示将原字符串重复 n 次。</p>
</blockquote>
<ul>
<li>n 表示重复 n 次</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="regexp">//</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>) <span class="regexp">//</span> <span class="string">&quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">0</span>) <span class="regexp">//</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="regexp">//</span>小数会被向下取整</span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">2.9</span>) <span class="regexp">//</span> <span class="string">&quot;nana&quot;</span></span><br><span class="line"><span class="regexp">//</span>参数是大于或等于-<span class="number">1</span>或者Infinity，会报错。</span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(Infinity) <span class="regexp">//</span> RangeError</span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(-<span class="number">1</span>) <span class="regexp">//</span> RangeError</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>参数是 <span class="number">0</span> 到-<span class="number">1</span> 之间的小数，则等同于 <span class="number">0</span>,因为会先进行取整运算</span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(-<span class="number">0.9</span>) <span class="regexp">//</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="regexp">//</span>参数NaN等同于 <span class="number">0</span>。</span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(NaN) <span class="regexp">//</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="regexp">//</span>参数是字符串，则会先转换成数字。</span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;3&#x27;</span>) <span class="regexp">//</span> <span class="string">&quot;nanana&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;na&#x27;</span>) <span class="regexp">//</span> <span class="string">&quot;&quot;</span>    <span class="string">&#x27;na&#x27;</span>.repeat(Number(<span class="string">&#x27;na&#x27;</span>))  Number(<span class="string">&#x27;na&#x27;</span>)=== NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>实例方法：padStart()与 padEnd()</strong> ES2017 引入了字符串补全长度的功能。返回一个新字符串</p>
</blockquote>
<ul>
<li><p>padStart(num,str) 头部补全</p>
</li>
<li><p>padEnd(num,str) 尾部补全</p>
<ul>
<li>num 将字符串补全为 num 位</li>
<li>str 需要填充的字符串</li>
</ul>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="regexp">//</span> <span class="string">&#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="regexp">//</span> <span class="string">&#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串</span><br><span class="line"><span class="string">&#x27;xxx&#x27;</span>.padStart(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="regexp">//</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="string">&#x27;xxx&#x27;</span>.padEnd(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="regexp">//</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0123456789&#x27;</span>) <span class="regexp">//</span> <span class="string">&#x27;0123456abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 省略第二个参数，默认使用空格补全长度</span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">&#x27;   x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">&#x27;x   &#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>**实例方法：trimStart()，trimEnd() ** ES2019 对字符串实例新增了 trimStart()和 trimEnd()这两个方法,与 trim()类似,返回一个新字符串</p>
</blockquote>
<ul>
<li>trimStart()</li>
<li>trimEnd()</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.trim() <span class="regexp">//</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">s.trimStart() <span class="regexp">//</span> <span class="string">&quot;abc  &quot;</span></span><br><span class="line">s.trimEnd() <span class="regexp">//</span> <span class="string">&quot;  abc&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>实例方法：matchAll()</strong> matchAll()方法返回一个正则表达式在当前字符串的所有匹配</p>
</blockquote>
<blockquote>
<p><strong>实例方法：replaceAll()</strong> ES2021 引入了 replaceAll()方法，可以一次性替换所有匹配。返回一个新字符串</p>
</blockquote>
<p>弥补 replace()只能替换第一个匹配的不足</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>replace()如果要替换所有的匹配，势必会使用正则表达式的g修饰符。</span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replace(<span class="regexp">/b/g</span>, <span class="string">&#x27;_&#x27;</span>) <span class="regexp">//</span> <span class="string">&#x27;aa_bcc&#x27;</span></span><br><span class="line"><span class="regexp">//</span>replaceAll() 会更加简洁</span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;_&#x27;</span>) <span class="regexp">//</span> <span class="string">&#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的扩展</title>
    <url>/2021/04/21/ES6/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Number-相关"><a href="#Number-相关" class="headerlink" title="Number 相关"></a>Number 相关</h3><blockquote>
<p>Number.isFinite(), Number.isNaN()</p>
</blockquote>
<p>ES6 在 Number 对象上，新提供了 Number.isFinite()和 Number.isNaN()两个方法</p>
<ul>
<li>Number.isFinite() 用来检查一个数值是不是 Infinity</li>
<li>Number.isNaN() 用来检查一个值是否为 NaN。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(15)</span>; <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(0.8)</span>; <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(NaN)</span>; <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(Infinity)</span>; <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(-Infinity)</span>; <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(&#x27;<span class="params">foo</span>&#x27;)</span>; <span class="comment">// false</span></span><br><span class="line"><span class="comment">//参数类型不是明确的数值，Number.isFinite一律返回false。</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(&#x27;15&#x27;)</span>; <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Finite(<span class="params">true</span>)</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&lt;!-- 参数类型不是NaN，<span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>isNaN一律返回<span class="literal">false</span>。 --&gt;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(NaN)</span> <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(15)</span> <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(&#x27;15&#x27;)</span> <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(<span class="params">true</span>)</span> <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(9<span class="operator">/</span>NaN)</span> <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(&#x27;<span class="params">true</span>&#x27; <span class="operator">/</span> 0)</span> <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(&#x27;<span class="params">true</span>&#x27; <span class="operator">/</span> &#x27;<span class="params">true</span>&#x27;)</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>与传统的全局方法 isFinite()和 isNaN()的区别</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>)  //<span class="literal">true</span>   传统方法<span class="built_in">isFinite</span>(<span class="built_in">Number</span>(<span class="string">&#x27;25&#x27;</span>))</span><br><span class="line"><span class="built_in">Number</span>.<span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>) //<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"><span class="built_in">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"><span class="built_in">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="regexp">//</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number.parseInt(), Number.parseFloat()<br>ES6 将全局方法 parseInt()和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.<span class="built_in">parseInt</span> === <span class="built_in">parseInt</span> <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"><span class="built_in">Number</span>.<span class="built_in">parseFloat</span> === <span class="built_in">parseFloat</span> <span class="regexp">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number.isInteger()</p>
</blockquote>
<p>Number.isInteger()用来判断一个数值是否为整数。但是局限性比较大</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer(25)</span> <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer(25.1)</span> <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer(25.0)</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数不是数值，Number.isInteger返回false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer()</span> <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer(<span class="params">null</span>)</span> <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer(&#x27;15&#x27;)</span> <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer(<span class="params">true</span>)</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">Integer(3.0000000000000002)</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Number.EPSILON 表示极小常量</p>
</blockquote>
<h3 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h3><p>以下方法都是静态方法，只能在 Math 对象上调用</p>
<blockquote>
<p>Math.trunc() 去除一个数的小数部分，返回整数部分。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc<span class="number">(-4.1)</span> <span class="comment">// -4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于非数值，Math.trunc内部使用Number方法将其先转为数值。</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(&#x27;<span class="number">123.456</span>&#x27;) <span class="comment">// 123</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(null) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于空值和无法截取整数的值，返回NaN。</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(NaN);      <span class="comment">// NaN</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(&#x27;foo&#x27;);    <span class="comment">// NaN</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc<span class="literal">()</span>;         <span class="comment">// NaN</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc(undefined) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于没有部署这个方法的环境，可以用下面的代码模拟。</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>trunc<span class="operator"> || </span><span class="keyword">function</span>(x) &#123;</span><br><span class="line">  return x &lt; <span class="number">0</span> ? <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>ceil(x) : <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Math.sign() 用来判断一个数到底是正数、负数、还是零。</p>
</blockquote>
<p>返回值</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为 0，返回 0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回 NaN。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign<span class="number">(-5)</span> <span class="comment">// -1</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign<span class="number">(-0)</span> <span class="comment">// -0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(NaN) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(&#x27;&#x27;)  <span class="comment">// 0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(<span class="literal">true</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(null)  <span class="comment">// 0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(<span class="character">&#x27;9&#x27;</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(&#x27;foo&#x27;)  <span class="comment">// NaN</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign<span class="literal">()</span>  <span class="comment">// NaN</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign(undefined)  <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于没有部署这个方法的环境，可以用下面的代码模拟。</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>sign<span class="operator"> || </span><span class="keyword">function</span>(x) &#123;</span><br><span class="line">  x = +x; <span class="comment">// convert to a number</span></span><br><span class="line">  <span class="keyword">if</span> (x<span class="operator"> === </span><span class="number">0</span><span class="operator"> || </span>is<span class="constructor">NaN(<span class="params">x</span>)</span>) &#123;</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line">  return x &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="BigInt-数据类型"><a href="#BigInt-数据类型" class="headerlink" title="BigInt 数据类型"></a>BigInt 数据类型</h3><p>ES2020 引入了一种新的数据类型 BigInt（大整数）<br>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀 n。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const a</span> = 2172141653n;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的扩展</title>
    <url>/2021/04/21/ES6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">function foo(a=<span class="number">1</span>,b)&#123;</span><br><span class="line">  console<span class="selector-class">.log</span>(<span class="selector-tag">a</span>,b)  <span class="comment">//1,undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>值得注意的是以下两种写法</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 写法一</span><br><span class="line"><span class="keyword">function</span> m1(&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 写法二</span><br><span class="line"><span class="keyword">function</span> m2(&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 函数没有参数的情况</span><br><span class="line">m1() <span class="regexp">//</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">m2() <span class="regexp">//</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;) <span class="regexp">//</span> [<span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">m2(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;) <span class="regexp">//</span> [<span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: <span class="number">3</span>&#125;) <span class="regexp">//</span> [<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">m2(&#123;x: <span class="number">3</span>&#125;) <span class="regexp">//</span> [<span class="number">3</span>, undefined]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) <span class="regexp">//</span> [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">m2(&#123;&#125;) <span class="regexp">//</span> [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: <span class="number">3</span>&#125;) <span class="regexp">//</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">m2(&#123;z: <span class="number">3</span>&#125;) <span class="regexp">//</span> [undefined, undefined]</span><br></pre></td></tr></table></figure>

<p>解析：<br>可以确定 m1，m2 的参数是一个对象。m1 相当于是声明了 x,y 的变量并初始化(let x=0,y=0)是 x,y 先有值再添加到对象上。实参传入后会覆盖掉形参的对象，原有的 x,y(传参完整的情况)，<br>当传参不全({x:1})时，y 仍然有值<br>m2 相当于是声明了 x,y 的变量,但是没有进行初始化。直接是形参对象有属性，当不传参时，形参对象解构赋值。传参不全时就会实参覆盖掉形参，这时可能就会只有 x,或 y 有值，另一个为 undefined 了。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length 属性将失真。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a)</span> </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a = 5)</span> </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a, b, c = 5)</span> </span>&#123;&#125;).length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//rest 参数也不会计入length属性。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a = 0, b, c)</span> </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">(a, b = 1, c)</span> </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域-重点，费了好一会才理清思路"><a href="#作用域-重点，费了好一会才理清思路" class="headerlink" title="作用域 重点，费了好一会才理清思路"></a>作用域 重点，费了好一会才理清思路</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。<br><strong>只有设置参数默认值时，才会出现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个例子</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个例子</span></span><br><span class="line">&lt;!-- 可以理解为在全局作用域与函数作用域中，存在一个偏向于函数作用域的作用域，我称呼它为函数内上层作用域（参数作用域）。<span class="keyword">let</span>是块级作用域，应该为函数的内下层作用域（函数作用域）。这两个作用域是独立的，遵循作用域链。</span><br><span class="line">参数作用域中，做的操作是给参数y赋值，y=x,但是x必须要有才能赋值，否则就会报错。x在该层作用域没有声明，只能根据作用域链只能找到全局作用域的x，所以y=<span class="number">1</span>。这是函数在初始化时就已经决定了参数的默认值。</span><br><span class="line"> --&gt;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;  <span class="comment">//全局的x如果不存在会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// let x=2 || x=2 这两种写法与var x=2没有任何区别，f()打印都为1</span></span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个例子</span></span><br><span class="line">&lt;!-- 参数作用域&#123;<span class="keyword">let</span> x,<span class="keyword">let</span> y=x&#125;,函数内下层作用域<span class="built_in">console</span>.log(x),找的是本作用域的x，打印<span class="number">3</span>;<span class="built_in">console</span>.log(y),根据作用域链寻找参数作用域的y,打印<span class="literal">undefined</span></span><br><span class="line"> --&gt;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span> <span class="comment">//这里是新的变量与参数作用的x，没有关系</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//3</span></span><br><span class="line">  <span class="built_in">console</span>.log(y)  <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四个例子</span></span><br><span class="line">&lt;!-- 与第三个例子区别在于函数内下层作用域x没有用<span class="keyword">var</span>声明。代表的是内下层作用域的x与参数作用域的x指向同一个变量。但是函数执行后，打印的结果是一样的。</span><br><span class="line">重点在于，两个作用域对x做了不同的操作。参数作用域：&#123;<span class="keyword">let</span> x,y=x&#125;,此时x,y都等于<span class="literal">undefined</span>，接着内下层作用域对x赋值，x=<span class="number">3</span>。至此，函数的变量为x=<span class="number">3</span>，y=<span class="literal">undefined</span>。接着打印两个变量</span><br><span class="line"> --&gt;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  x = <span class="number">3</span> <span class="comment">//指向参数作用域的x</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//3</span></span><br><span class="line">  <span class="built_in">console</span>.log(y)  <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">//1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面再来两个类似的例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四个例子</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();  <span class="comment">//将参数作用域的x赋值为2，但是函数内下层作用域的x不受影响</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第五个例子</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y();  <span class="comment">//将x重新赋值为2</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。<br>arguments 是一个伪数组，rest 是一个真正的数组<br>rest 位于参数的最后，否则报错</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="rest_arg">...values</span>)</span> </span>&#123;</span><br><span class="line">  let sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a, <span class="rest_arg">...b</span>, c)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的length属性，不包括 rest 参数。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...a</span>)</span> </span>&#123;&#125;).length  <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a, <span class="rest_arg">...b</span>)</span> </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>从 ES5 开始，函数内部可以设定为严格模式。<br>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>函数的 name 属性，返回该函数的函数名。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> foo() &#123;&#125;</span><br><span class="line">foo.name <span class="regexp">//</span> <span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>将一个匿名函数赋值给一个变量</span><br><span class="line">var f = <span class="keyword">function</span> () &#123;&#125;;</span><br><span class="line"><span class="regexp">//</span> ES5</span><br><span class="line">f.name <span class="regexp">//</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="regexp">//</span> ES6</span><br><span class="line">f.name <span class="regexp">//</span> <span class="string">&quot;f&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>将一个具名函数赋值给一个变量</span><br><span class="line">const bar = <span class="keyword">function</span> baz() &#123;&#125;;</span><br><span class="line"><span class="regexp">//</span> ES5</span><br><span class="line">bar.name <span class="regexp">//</span> <span class="string">&quot;baz&quot;</span></span><br><span class="line"><span class="regexp">//</span> ES6</span><br><span class="line">bar.name <span class="regexp">//</span> <span class="string">&quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>Function构造函数返回的函数实例</span><br><span class="line">(new Function).name <span class="regexp">//</span> <span class="string">&quot;anonymous&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>bind返回的函数,name属性值会加上bound前缀。</span><br><span class="line"><span class="keyword">function</span> foo() &#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="regexp">//</span> <span class="string">&quot;bound foo&quot;</span></span><br><span class="line">(<span class="keyword">function</span>()&#123;&#125;).bind(&#123;&#125;).name <span class="regexp">//</span> <span class="string">&quot;bound &quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数使用已经足够常见了。这里记录一下，注意事项。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">// 箭头函数简写返回一个对象，需要将对象用括号包裹</span><br><span class="line"><span class="keyword">let</span> getTempItem =<span class="built_in"> id</span> =&gt; (&#123;<span class="built_in"> id</span>:<span class="built_in"> id</span>,<span class="built_in"> name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>箭头函数 this 指向定义该方法时所在对象的上层作用域的对象</strong><br><strong>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</strong><br><strong>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</strong><br><strong>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</strong></p>
<h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p>尾调用指某个函数的最后一步是调用另一个函数<br>尾调用优化指只保留内层函数的调用帧<br>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br>尾调用模式仅在严格模式下生效</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>如果尾调用自身，就称为尾递归<br>尾递归改写形式有点难以看出怎么实现函数功能</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常的递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n, total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数的方式改写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n, total = 1)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<h3 id="对-toString-的修改"><a href="#对-toString-的修改" class="headerlink" title="对 toString()的修改"></a>对 toString()的修改</h3><p>ES2019 对函数实例的 toString()方法做出了修改。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>不显示注释</span><br><span class="line"><span class="keyword">function</span> <span class="regexp">/* foo comment */</span> foo () &#123;&#125;</span><br><span class="line">foo.toString()</span><br><span class="line"><span class="regexp">//</span> <span class="keyword">function</span> foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>修改后的toString()方法，明确要求返回一模一样的原始代码。</span><br><span class="line"><span class="keyword">function</span> <span class="regexp">/* foo comment */</span> foo () &#123;&#125;</span><br><span class="line">foo.toString()</span><br><span class="line"><span class="regexp">//</span> <span class="string">&quot;function /* foo comment */ foo () &#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="catch-命令的参数省略"><a href="#catch-命令的参数省略" class="headerlink" title="catch 命令的参数省略"></a>catch 命令的参数省略</h3><p>ES2019 做出了改变，允许 catch 语句省略参数。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>明确要求catch后必须带参数</span><br><span class="line">try &#123;</span><br><span class="line">  <span class="regexp">//</span> ...</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  <span class="regexp">//</span> 处理错误</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>ES2019 做出了改变，允许catch语句省略参数。</span><br><span class="line">try &#123;</span><br><span class="line">  <span class="regexp">//</span> ...</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  <span class="regexp">//</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的扩展</title>
    <url>/2021/04/22/ES6/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="扩展运算符-‘…’"><a href="#扩展运算符-‘…’" class="headerlink" title="扩展运算符 ‘…’"></a>扩展运算符 ‘…’</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">console.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>函数调用可以传参</span><br><span class="line"><span class="keyword">function</span> add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line">const numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="regexp">//</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>替代函数的 apply 方法</span><br><span class="line"><span class="regexp">//</span> ES5 的写法</span><br><span class="line"><span class="keyword">function</span> f(x, y, z) &#123;</span><br><span class="line">  <span class="regexp">//</span> ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"><span class="regexp">//</span> ES6的写法</span><br><span class="line"><span class="keyword">function</span> f(x, y, z) &#123;</span><br><span class="line">  <span class="regexp">//</span> ...</span><br><span class="line">&#125;</span><br><span class="line">let args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>克隆数组</span><br><span class="line"><span class="regexp">//</span>ES5</span><br><span class="line">const a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="regexp">//</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>ES6</span><br><span class="line">const a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="regexp">//</span> 写法一</span><br><span class="line">const a2 = [...a1];</span><br><span class="line"><span class="regexp">//</span> 写法二</span><br><span class="line">const [...a2] = a1;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>合并数组  以下合并方法都是浅拷贝</span><br><span class="line">const arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">const arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">const arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"><span class="regexp">//</span> ES5 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="regexp">//</span> [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span> ]</span><br><span class="line"><span class="regexp">//</span> ES6 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="regexp">//</span> [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>与解构赋值结合  扩展运算符放最后</span><br><span class="line">const [a,...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">console.log(a) <span class="regexp">//</span><span class="number">1</span></span><br><span class="line">console.log(b) [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>将字符串转为数组</span><br><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="regexp">//</span>[ <span class="string">&quot;h&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>任何定义了遍历器（Iterator）接口的对象都可以用扩展运算符转为真正的数组。</span><br><span class="line">let nodeList = document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">let array = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。</span><br><span class="line">扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。</span><br><span class="line">let arrayLike = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="regexp">//</span> TypeError: Cannot spread non-iterable object.</span><br><span class="line">let arr = [...arrayLike];   <span class="regexp">//</span>可以改为使用Array.from方法将arrayLike转为真正的数组。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组静态方法"><a href="#数组静态方法" class="headerlink" title="数组静态方法"></a>数组静态方法</h3><h4 id="Array-from-likeArr-callback-obj-Array-from-方法用于将两类对象转为真正的数组：类似数组的对象（必须有-length-属性。例如：arguments）和可遍历（iterable）的对象"><a href="#Array-from-likeArr-callback-obj-Array-from-方法用于将两类对象转为真正的数组：类似数组的对象（必须有-length-属性。例如：arguments）和可遍历（iterable）的对象" class="headerlink" title="Array.from(likeArr,callback,obj) Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（必须有 length 属性。例如：arguments）和可遍历（iterable）的对象"></a>Array.from(likeArr,callback,obj) Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（必须有 length 属性。例如：arguments）和可遍历（iterable）的对象</h4><ul>
<li>likeArr 类似数组的对象或可遍历对象</li>
<li>callback 类似数组的 map 方法。用来对每个元素进行处理，将处理后的值放入返回的数组。</li>
<li>obj 如果 callback 中用到 this，则提供绑定的 this 对象</li>
</ul>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">et arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="meta">length</span>: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.<span class="meta">call</span>(arrayLike); // [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = <span class="meta">Array</span>.<span class="meta">from</span>(arrayLike); // [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line">//要是部署了 Iterator 接口的数据结构，<span class="meta">Array</span>.<span class="meta">from</span>都能将其转为数组。</span><br><span class="line"><span class="meta">Array</span>.<span class="meta">from</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">// [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line">let namesSet = new <span class="meta">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="meta">Array</span>.<span class="meta">from</span>(namesSet) // [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">//参数是一个真正的数组，<span class="meta">Array</span>.<span class="meta">from</span>会返回一个一模一样的新数组。可以实现浅克隆</span><br><span class="line"><span class="meta">Array</span>.<span class="meta">from</span>([1, 2, 3])</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">//<span class="meta">Array</span>.<span class="meta">from</span>()第二个参数</span><br><span class="line"><span class="meta">Array</span>.<span class="meta">from</span>(arrayLike, <span class="meta">x</span> =&gt; <span class="meta">x</span> <span class="comment">* x);</span></span><br><span class="line">// 等同于</span><br><span class="line"><span class="meta">Array</span>.<span class="meta">from</span>(arrayLike).map(<span class="meta">x</span> =&gt; <span class="meta">x</span> <span class="comment">* x);</span></span><br><span class="line"><span class="meta">Array</span>.<span class="meta">from</span>([1, 2, 3], (<span class="meta">x</span>) =&gt; <span class="meta">x</span> <span class="comment">* x)</span></span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<h4 id="Array-of-Array-of-方法用于将一组值，转换为数组。"><a href="#Array-of-Array-of-方法用于将一组值，转换为数组。" class="headerlink" title="Array.of() Array.of()方法用于将一组值，转换为数组。"></a>Array.of() Array.of()方法用于将一组值，转换为数组。</h4><p>弥补数组构造函数 Array()的不足。因为参数个数的不同，会导致 Array()的行为有差异。Array.of()基本可以替代 Array()和 new Array()</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Array<span class="selector-class">.of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line">Array<span class="selector-class">.of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line">Array<span class="selector-class">.of</span>(<span class="number">3</span>)<span class="selector-class">.length</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Array会存在留空的情况</span></span><br><span class="line"><span class="function"><span class="title">Array</span><span class="params">()</span></span> <span class="comment">// []</span></span><br><span class="line"><span class="function"><span class="title">Array</span><span class="params">(<span class="number">3</span>)</span></span> <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="function"><span class="title">Array</span><span class="params">(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)</span></span> <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的实例方法"><a href="#数组的实例方法" class="headerlink" title="数组的实例方法"></a>数组的实例方法</h3><h4 id="copyWithin-target-start-end-修改当前数组。将指定片段的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。"><a href="#copyWithin-target-start-end-修改当前数组。将指定片段的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。" class="headerlink" title="copyWithin(target,start,end) 修改当前数组。将指定片段的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。"></a>copyWithin(target,start,end) 修改当前数组。将指定片段的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</h4><p>选取的片段遵守左闭右合原则[start,end)</p>
<ul>
<li>target (必需) 从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start (可选) 选择的片段起始位置。默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end (可选) 选择片段的结束位置。默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[1, 2, 3, 4, 5]</span><span class="selector-class">.copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line"><span class="selector-attr">[1, 2, 3, 4, 5]</span><span class="selector-class">.copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="find-callback-obj-用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数。找到返回-true，没有返回-undefined"><a href="#find-callback-obj-用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数。找到返回-true，没有返回-undefined" class="headerlink" title="find(callback,obj) 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数。找到返回 true，没有返回 undefined"></a>find(callback,obj) 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数。找到返回 true，没有返回 undefined</h4><ul>
<li>callback<ul>
<li>value 当前的值</li>
<li>index 当前值得索引</li>
<li>array 原数组</li>
</ul>
</li>
<li>obj 如果 callback 中用到 this，则提供绑定的 this 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//find()第二个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="built_in">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);    <span class="comment">// 26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Object.is()可以识别NaN</span></span><br><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)  <span class="comment">//-1</span></span><br><span class="line">[<span class="literal">NaN</span>].find(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">Object</span>.is(val,<span class="literal">NaN</span>)) <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="findIndex-callback-obj-返回第一个符合条件的数组成员的索引，如果所有成员都不符合条件，则返回-1。"><a href="#findIndex-callback-obj-返回第一个符合条件的数组成员的索引，如果所有成员都不符合条件，则返回-1。" class="headerlink" title="findIndex(callback,obj) 返回第一个符合条件的数组成员的索引，如果所有成员都不符合条件，则返回-1。"></a>findIndex(callback,obj) 返回第一个符合条件的数组成员的索引，如果所有成员都不符合条件，则返回-1。</h4><ul>
<li>callback<ul>
<li>value 当前的值</li>
<li>index 当前值得索引</li>
<li>array 原数组</li>
</ul>
</li>
<li>obj 如果 callback 中用到 this，则提供绑定的 this 对象</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="literal">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]</span>.find<span class="constructor">Index(<span class="params">function</span>(<span class="params">value</span>, <span class="params">index</span>, <span class="params">arr</span>)</span> &#123;</span><br><span class="line">  return value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Object.is()可以识别NaN</span></span><br><span class="line"><span class="literal">[N<span class="identifier">aN</span>]</span>.index<span class="constructor">Of(NaN)</span>  <span class="comment">//-1</span></span><br><span class="line"><span class="literal">[N<span class="identifier">aN</span>]</span>.find<span class="constructor">Index(<span class="params">val</span> =&gt; Object.<span class="params">is</span>(<span class="params">val</span>,NaN)</span>) <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="fill-val-start-end-使用给定值，填充一个数组。"><a href="#fill-val-start-end-使用给定值，填充一个数组。" class="headerlink" title="fill(val,start,end) 使用给定值，填充一个数组。"></a>fill(val,start,end) 使用给定值，填充一个数组。</h4><p>填充位置遵循左闭右合原则 [start,end)</p>
<ul>
<li>val 填充值</li>
<li>start 填充的起始位置</li>
<li>end 填充的结束位置</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="regexp">//</span> [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">new Array(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="regexp">//</span> [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&#x27;a&#x27;</span>, <span class="number">7</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>如果填充为一个引用类型，则为浅拷贝</span><br><span class="line">let arr = new Array(<span class="number">3</span>).fill(&#123;name: <span class="string">&quot;Mike&quot;</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">&quot;Ben&quot;</span>;</span><br><span class="line"><span class="regexp">//</span> [&#123;name: <span class="string">&quot;Ben&quot;</span>&#125;, &#123;name: <span class="string">&quot;Ben&quot;</span>&#125;, &#123;name: <span class="string">&quot;Ben&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="entries-，keys-和-values-用于遍历数组-它们都返回一个遍历器对象。可以用-for…of-遍历-entries-是键值对的遍历。keys-和-values-分别是键和值的遍历"><a href="#entries-，keys-和-values-用于遍历数组-它们都返回一个遍历器对象。可以用-for…of-遍历-entries-是键值对的遍历。keys-和-values-分别是键和值的遍历" class="headerlink" title="entries()，keys() 和 values() 用于遍历数组,它们都返回一个遍历器对象。可以用 for…of 遍历 entries()是键值对的遍历。keys() 和 values()分别是键和值的遍历"></a>entries()，keys() 和 values() 用于遍历数组,它们都返回一个遍历器对象。可以用 for…of 遍历 entries()是键值对的遍历。keys() 和 values()分别是键和值的遍历</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>keys()</span><br><span class="line"><span class="keyword">for</span> (let index of [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> <span class="number">0</span></span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>values()</span><br><span class="line"><span class="keyword">for</span> (let elem of [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="regexp">//</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>entries()</span><br><span class="line"><span class="keyword">for</span> (let [index, elem] of [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> <span class="number">0</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="string">&quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>如果还可以使用遍历器对象的<span class="keyword">next</span>(),手动遍历</span><br><span class="line">let letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">let entries = letter.entries();</span><br><span class="line">console.log(entries.<span class="keyword">next</span>().value); <span class="regexp">//</span> [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">console.log(entries.<span class="keyword">next</span>().value); <span class="regexp">//</span> [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">console.log(entries.<span class="keyword">next</span>().value); <span class="regexp">//</span> [<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="includes-val-start-表示某个数组是否包含给定的值，包含返回-true，不包含返回-false"><a href="#includes-val-start-表示某个数组是否包含给定的值，包含返回-true，不包含返回-false" class="headerlink" title="includes(val,start) 表示某个数组是否包含给定的值，包含返回 true，不包含返回 false"></a>includes(val,start) 表示某个数组是否包含给定的值，包含返回 true，不包含返回 false</h4><ul>
<li>val 要查询的值</li>
<li>查询的起始位置</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">[1, 2, 3]<span class="string">.includes</span><span class="params">(2)</span>     <span class="string">//</span> <span class="literal">true</span></span><br><span class="line">[1, 2, 3]<span class="string">.includes</span><span class="params">(4)</span>     <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">[1, 2, NaN]<span class="string">.includes</span><span class="params">(NaN)</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[1, 2, 3]<span class="string">.includes</span><span class="params">(3, 3)</span>;  <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">[1, 2, 3]<span class="string">.includes</span><span class="params">(3, -1)</span>; <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="flat-，flatMap-callback-obj-这两个方法可以将数组扁平化，返回一个新数组"><a href="#flat-，flatMap-callback-obj-这两个方法可以将数组扁平化，返回一个新数组" class="headerlink" title="flat()，flatMap(callback,obj) 这两个方法可以将数组扁平化，返回一个新数组"></a>flat()，flatMap(callback,obj) 这两个方法可以将数组扁平化，返回一个新数组</h4><p>flat()可以自定义扁平化几层，flatMap()只会扁平化一层</p>
<ul>
<li>callback 相当于一个 map()</li>
<li>obj 如果 callback 中有 this，则提供 this 绑定对象</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">//默认扁平化一层</span><br><span class="line"><span class="comment">[1, 2, <span class="comment">[3, 4]</span>]</span>.flat()</span><br><span class="line">// <span class="comment">[1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">[1, 2, <span class="comment">[3, <span class="comment">[4, 5]</span>]</span>]</span>.flat()</span><br><span class="line">// <span class="comment">[1, 2, 3, <span class="comment">[4, 5]</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">[1, 2, <span class="comment">[3, <span class="comment">[4, 5]</span>]</span>]</span>.flat(2)</span><br><span class="line">// <span class="comment">[1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">//如果有空位，则压缩空位</span><br><span class="line"><span class="comment">[1, 2, , 4, 5]</span>.flat()</span><br><span class="line">// <span class="comment">[1, 2, 4, 5]</span></span><br><span class="line"></span><br><span class="line">//使用Infinity关键字，可以将多维数组扁平化为一维数组</span><br><span class="line"><span class="comment">[1, <span class="comment">[2, <span class="comment">[3]</span>]</span>]</span>.flat(Infinity)</span><br><span class="line">// <span class="comment">[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">// 相当于 <span class="comment">[<span class="comment">[2, 4]</span>, <span class="comment">[3, 6]</span>, <span class="comment">[4, 8]</span>]</span>.flat()</span><br><span class="line"><span class="comment">[2, 3, 4]</span>.flatMap((x) =&gt; <span class="comment">[x, x * 2]</span>)</span><br><span class="line">// <span class="comment">[2, 4, 3, 6, 4, 8]</span></span><br><span class="line"></span><br><span class="line">// 相当于 <span class="comment">[<span class="comment">[<span class="comment">[2]</span>]</span>, <span class="comment">[<span class="comment">[4]</span>]</span>, <span class="comment">[<span class="comment">[6]</span>]</span>, <span class="comment">[<span class="comment">[8]</span>]</span>]</span>.flat()</span><br><span class="line"><span class="comment">[1, 2, 3, 4]</span>.flatMap(x =&gt; <span class="comment">[<span class="comment">[x * 2]</span>]</span>)</span><br><span class="line">// <span class="comment">[<span class="comment">[2]</span>, <span class="comment">[4]</span>, <span class="comment">[6]</span>, <span class="comment">[8]</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Array和newArray都会有空位存在</span></span><br><span class="line"><span class="function"><span class="title">Array</span><span class="params">(<span class="number">3</span>)</span></span> <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>

<p>ES5 大多数会忽略空位<br>ES6 明确将空位视为 undefined</p>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的扩展</title>
    <url>/2021/04/22/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>这个特性目前已经应用比较广泛</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>同名变量简写、方法简写</span><br><span class="line">const foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">const baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="regexp">//</span> &#123;foo: <span class="string">&quot;bar&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 等同于</span><br><span class="line">const baz = &#123;foo: foo&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 方法一</span><br><span class="line">obj.foo = true;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 属性名表达式需要放置在方括号内</span><br><span class="line">obj[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>] = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>方法名使用表达式</span><br><span class="line">let obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    return <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.hello() <span class="regexp">//</span> hi</span><br></pre></td></tr></table></figure>

<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<blockquote>
<p>首先遍历所有数值键，按照数值升序排列。<br>其次遍历所有字符串键，按照加入时间升序排列。<br>最后遍历所有 Symbol 键，按照加入时间升序排列。</p>
</blockquote>
<ul>
<li>for…in<br>for…in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li>
<li>Object.keys(obj)<br>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</li>
<li>Object.getOwnPropertyNames(obj)<br>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</li>
<li>Object.getOwnPropertySymbols(obj)<br>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li>
<li>Reflect.ownKeys(obj)<br>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li>
</ul>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>super、class 和各种借口类让我感觉 js 越来越像 java 了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并且super关键字表示原型对象时只能用在对象的方法简写中</span></span><br><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo; <span class="comment">//等价于Object.getPrototypeOf(this).foo</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//会报错</span></span><br><span class="line">  <span class="comment">//find: ()=&gt; super.foo</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h4><p>ES2018 将这个运算符引入了对象。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let &#123; x, y, ...z &#125; = &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, a: <span class="number">3</span>, b: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</span><br><span class="line">let o1 = &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line">let o2 = &#123; b: <span class="number">2</span> &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line">let &#123; ...o3 &#125; = o2;</span><br><span class="line">o3 <span class="regexp">//</span> &#123; b: <span class="number">2</span> &#125;</span><br><span class="line">o3.a <span class="regexp">//</span> undefined</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>例子</span><br><span class="line">const o = Object.create(&#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;);  <span class="regexp">//</span>Object.create()创建了一个新对象，它的原型为&#123;x:<span class="number">1</span>,y:<span class="number">2</span>&#125;</span><br><span class="line">o.z = <span class="number">3</span>;</span><br><span class="line">let &#123; x, ...newObj &#125; = o; <span class="regexp">//</span>x是单纯的解构赋值，可以取到原型上的x</span><br><span class="line">let &#123; y, z &#125; = newObj;</span><br><span class="line">x <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">y <span class="regexp">//</span> undefined</span><br><span class="line">z <span class="regexp">//</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>对象的扩展运算符特殊场景</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>等同于使用Object.assign()方法</span><br><span class="line">let foo = &#123; ...[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] &#125;;</span><br><span class="line">foo</span><br><span class="line"><span class="regexp">//</span> &#123;<span class="number">0</span>: <span class="string">&quot;a&quot;</span>, <span class="number">1</span>: <span class="string">&quot;b&quot;</span>, <span class="number">2</span>: <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>扩展运算符后面是一个空对象，则没有任何效果</span><br><span class="line">&#123;...&#123;&#125;, a: <span class="number">1</span>&#125;</span><br><span class="line"><span class="regexp">//</span> &#123; a: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>扩展运算符后面不是对象，则会自动将其转为对象</span><br><span class="line"><span class="regexp">//</span> 等同于 &#123;...Object(<span class="number">1</span>)&#125;</span><br><span class="line">&#123;...<span class="number">1</span>&#125; <span class="regexp">//</span> &#123;&#125;</span><br><span class="line"><span class="regexp">//</span> 等同于 &#123;...Object(true)&#125;</span><br><span class="line">&#123;...true&#125; <span class="regexp">//</span> &#123;&#125;</span><br><span class="line"><span class="regexp">//</span> 等同于 &#123;...Object(undefined)&#125;</span><br><span class="line">&#123;...undefined&#125; <span class="regexp">//</span> &#123;&#125;</span><br><span class="line"><span class="regexp">//</span> 等同于 &#123;...Object(null)&#125;</span><br><span class="line">&#123;...null&#125; <span class="regexp">//</span> &#123;&#125;</span><br><span class="line"><span class="regexp">//</span>值得注意的是如果运算符后面是字符串，则自动转成一个类似数组的对象</span><br><span class="line">&#123;...<span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line"><span class="regexp">//</span> &#123;<span class="number">0</span>: <span class="string">&quot;h&quot;</span>, <span class="number">1</span>: <span class="string">&quot;e&quot;</span>, <span class="number">2</span>: <span class="string">&quot;l&quot;</span>, <span class="number">3</span>: <span class="string">&quot;l&quot;</span>, <span class="number">4</span>: <span class="string">&quot;o&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</span><br><span class="line">let a = &#123;</span><br><span class="line">  get x() &#123;</span><br><span class="line">    throw new Error(<span class="string">&#x27;not throw yet&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let aWithXGetter = &#123; ...a &#125;; <span class="regexp">//</span> 报错</span><br></pre></td></tr></table></figure>

<h4 id="链判断运算符-‘-’"><a href="#链判断运算符-‘-’" class="headerlink" title="链判断运算符 ‘?.’"></a>链判断运算符 ‘?.’</h4><p>?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>判断对象的属性是否存在</span><br><span class="line">let obj = &#123;a:<span class="number">1</span>&#125;</span><br><span class="line">obj?.a  <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">abj?.b  <span class="regexp">//</span>不存在返回undefined</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>函数或对象的方法调用。对于某些未实现的方法很好用</span><br><span class="line"><span class="keyword">if</span> (myForm.checkValidity?.() === false) &#123;</span><br><span class="line">  <span class="regexp">//</span> 表单校验失败</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>判断数组元素是否存在</span><br><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr?.[<span class="number">0</span>]  <span class="regexp">//</span><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Null-判断运算符-‘-’"><a href="#Null-判断运算符-‘-’" class="headerlink" title="Null 判断运算符 ‘??’"></a>Null 判断运算符 ‘??’</h4><p>ES2020 引入了一个新的 Null 判断运算符??。有运算符左侧的值为 null 或 undefined 时，才会返回右侧的值。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>当左侧为undefined或null返回右边的值</span><br><span class="line">let obj = &#123;b: null&#125;</span><br><span class="line">obj.a ?? <span class="number">1</span>  <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">obj.b ?? <span class="number">2</span> <span class="regexp">//</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>null 判断运算符’??’与链判断符’?.’可以设置为 null 或 undefined 设置初始值</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> arr =<span class="meta"> [1,2, ,]</span></span><br><span class="line"><span class="attribute">arr</span>[<span class="number">3</span>] = arr?.[<span class="number">2</span>] ?? <span class="number">3</span>  //arr[<span class="number">3</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的新增方法</title>
    <url>/2021/04/21/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="Object-is-val1-val2-比较两个值是否相等"><a href="#Object-is-val1-val2-比较两个值是否相等" class="headerlink" title="Object.is(val1,val2) 比较两个值是否相等"></a>Object.is(val1,val2) 比较两个值是否相等</h4><p>扩展了 ES5 同值相等算法，与 === 基本类似</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>与<span class="string">&#x27;===&#x27;</span>不同之处</span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> //<span class="literal">true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="regexp">//</span> <span class="literal">false</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(+<span class="number">0</span>, <span class="number">-0</span>) <span class="regexp">//</span> <span class="literal">false</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-assign-target-source1-…-sourcen-用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。"><a href="#Object-assign-target-source1-…-sourcen-用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。" class="headerlink" title="Object.assign(target,source1,…,sourcen) 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。"></a>Object.assign(target,source1,…,sourcen) 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</h4><ul>
<li>target 目标对象，源对象会遍历合并到它身上</li>
<li>source 源对象，会将其遍历合并到目标对象。如果多个源对象属性存在命名冲突，则靠后的属性会覆盖掉靠前的属性</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const target = &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;;</span><br><span class="line">const source1 = &#123; b: <span class="number">2</span>, c: <span class="number">2</span> &#125;;</span><br><span class="line">const source2 = &#123; c: <span class="number">3</span> &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target <span class="regexp">//</span> &#123;a:<span class="number">1</span>, b:<span class="number">2</span>, c:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>如果只有一个参数，Object.assign()会直接返回该参数。</span><br><span class="line">const obj = &#123;a: <span class="number">1</span>&#125;;</span><br><span class="line">Object.assign(obj) === obj <span class="regexp">//</span> true</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>该参数不是对象，则会先转成对象返回</span><br><span class="line">typeof Object.assign(<span class="number">2</span>) <span class="regexp">//</span> <span class="string">&quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>字符串会与数组的方式拷贝入对象</span><br><span class="line">const str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">Object.assign(&#123;&#125;,str) <span class="regexp">//</span>&#123;<span class="number">0</span>:<span class="string">&#x27;h&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;e&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;l&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;l&#x27;</span>,<span class="number">4</span>:<span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//u</span>ndefined和null无法转成对象，所以如果它们作为首位参数，就会报错。</span><br><span class="line">Object.assign(undefined) <span class="regexp">//</span> 报错</span><br><span class="line">Object.assign(null) <span class="regexp">//</span> 报错</span><br><span class="line"><span class="regexp">//u</span>ndefined和null不在首位不报错</span><br><span class="line">Object.assign(obj, undefined) === obj <span class="regexp">//</span> true</span><br><span class="line">Object.assign(obj, null) === obj <span class="regexp">//</span> true</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>Object.assign()可以处理数组，但是会将数组当成对象</span><br><span class="line"><span class="regexp">//</span>把数组视为属性名为 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span> 的对象，因此源数组的 <span class="number">0</span> 号属性<span class="number">4</span>覆盖了目标数组的 <span class="number">0</span> 号属性<span class="number">1</span>。</span><br><span class="line">Object.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])  <span class="regexp">//</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以实现对象浅克隆。只克隆源对象的自身属性（不克隆继承属性），也克隆不可枚举的属性（enumerable: false）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object.assign()实现浅克隆</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: [<span class="number">1</span>] &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.b === obj2.b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>取值函数的处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-getOwnPropertyDescriptors-obj"><a href="#Object-getOwnPropertyDescriptors-obj" class="headerlink" title="Object.getOwnPropertyDescriptors(obj)"></a>Object.getOwnPropertyDescriptors(obj)</h4><p>ES2017 引入了 Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</span><br><span class="line">const obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  get bar() &#123; return <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="regexp">//</span> &#123; foo:</span><br><span class="line"><span class="regexp">//</span>    &#123; value: <span class="number">123</span>,</span><br><span class="line"><span class="regexp">//</span>      writable: true,</span><br><span class="line"><span class="regexp">//</span>      enumerable: true,</span><br><span class="line"><span class="regexp">//</span>      configurable: true &#125;,</span><br><span class="line"><span class="regexp">//</span>   bar:</span><br><span class="line"><span class="regexp">//</span>    &#123; get: [Function: get bar],</span><br><span class="line"><span class="regexp">//</span>      set: undefined,</span><br><span class="line"><span class="regexp">//</span>      enumerable: true,</span><br><span class="line"><span class="regexp">//</span>      configurable: true &#125; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决Object.assign()无法正确拷贝get属性和set属性的问题。</span></span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source); <span class="comment">// &#123;foo: undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-getPrototypeOf-obj-返回参数对象的原型对象-obj-proto"><a href="#Object-getPrototypeOf-obj-返回参数对象的原型对象-obj-proto" class="headerlink" title="Object.getPrototypeOf(obj) 返回参数对象的原型对象(obj.__proto__)"></a>Object.getPrototypeOf(obj) 返回参数对象的原型对象(obj.__proto__)</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(&#123; <span class="params">__proto__</span>: <span class="params">null</span> &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果参数不是对象，会自动转化为对象</span></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(1)</span></span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(String(&#x27;foo&#x27;))</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(&#x27;<span class="params">foo</span>&#x27;)</span></span><br><span class="line"><span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(<span class="params">true</span>)</span></span><br><span class="line"><span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(1)</span><span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>prototype <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(&#x27;<span class="params">foo</span>&#x27;)</span><span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>prototype <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(<span class="params">true</span>)</span><span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Boolean</span>.</span></span>prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-setPrototypeOf-obj-proto-设置参数对象-obj-的原型对象，返回参数对象本身-obj"><a href="#Object-setPrototypeOf-obj-proto-设置参数对象-obj-的原型对象，返回参数对象本身-obj" class="headerlink" title="Object.setPrototypeOf(obj,proto) 设置参数对象(obj)的原型对象，返回参数对象本身(obj)"></a>Object.setPrototypeOf(obj,proto) 设置参数对象(obj)的原型对象，返回参数对象本身(obj)</h4><ul>
<li>obj 参数对象</li>
<li>proto 将 proto 设置为 obj 的原型对象</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>set<span class="constructor">PrototypeOf(<span class="params">object</span>, <span class="params">prototype</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">const o = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>set<span class="constructor">PrototypeOf(&#123;&#125;, <span class="params">null</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; x: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>set<span class="constructor">PrototypeOf(<span class="params">obj</span>, <span class="params">proto</span>)</span>;</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-entries-返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。"><a href="#Object-entries-返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。" class="headerlink" title="Object.entries() 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。"></a>Object.entries() 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">onst obj = &#123; foo: <span class="string">&#x27;bar&#x27;</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line">Object.entries(obj)</span><br><span class="line"><span class="regexp">//</span> [ [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>], [<span class="string">&quot;baz&quot;</span>, <span class="number">42</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</span><br><span class="line">Object.entries(&#123; [Symbol()]: <span class="number">123</span>, foo: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="regexp">//</span> [ [ <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;abc&#x27;</span> ] ]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>可以将对象转化为Map结构</span><br><span class="line">const obj = &#123; foo: <span class="string">&#x27;bar&#x27;</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line">const map = new Map(Object.entries(obj));</span><br><span class="line">map <span class="regexp">//</span> Map &#123; foo: <span class="string">&quot;bar&quot;</span>, baz: <span class="number">42</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-keys-obj-返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。"><a href="#Object-keys-obj-返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。" class="headerlink" title="Object.keys(obj) 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。"></a>Object.keys(obj) 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">&#x27;bar&#x27;</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line">Object.keys(obj)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;baz&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Object-values-obj-返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。"><a href="#Object-values-obj-返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。" class="headerlink" title="Object.values(obj) 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。"></a>Object.values(obj) 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const obj = &#123; foo: <span class="string">&#x27;bar&#x27;</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&quot;bar&quot;</span>, <span class="number">42</span>]</span><br><span class="line"></span><br><span class="line">const obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">Object.values(obj)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>]  <span class="regexp">//</span>遍历时排列为键值大小排序</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>Object.values会过滤属性名为 Symbol 值的属性。</span><br><span class="line">Object.values(&#123; [Symbol()]: <span class="number">123</span>, foo: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组</span><br><span class="line">Object.values(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>let 和 const</title>
    <url>/2021/04/22/ES6/let%E5%92%8Cconst/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul>
<li>不会提升变量</li>
<li>不允许重复声明</li>
<li>具有块级作用域<ul>
<li>暂时性死区</li>
</ul>
</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br><span class="line">var <span class="keyword">a</span> = <span class="number">10</span>   <span class="comment"> //10</span></span><br><span class="line"></span><br><span class="line">//不允许变量提升</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br><span class="line">let <span class="keyword">a</span> = <span class="number">10</span> <span class="comment"> //报错ReferenceError</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//let 具有块级作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">//不允许重复声明，报错</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="literal">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="literal">PI</span> <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line"><span class="literal">PI</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p><strong>本质</strong><br>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const a = [];</span><br><span class="line">a.push(<span class="string">&#x27;Hello&#x27;</span>); <span class="regexp">//</span> 可执行</span><br><span class="line">a.length = <span class="number">0</span>;    <span class="regexp">//</span> 可执行</span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="regexp">//</span> 报错</span><br></pre></td></tr></table></figure>

<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/2021/04/11/git/git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-新建本地git仓库"><a href="#1-新建本地git仓库" class="headerlink" title="1.新建本地git仓库"></a>1.新建本地git仓库</h2><p>1.1 git init   // 初始化版本库<br>1.2 git add .   // 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件 ，*会忽略一部分文件</p>
<p>1.3 git commit -m “first commit” // 把添加的文件提交到版本库，并填写提交备注</p>
<h2 id="2-更新代码步骤-（先检查当前状态，再更新，避免发生冲突）"><a href="#2-更新代码步骤-（先检查当前状态，再更新，避免发生冲突）" class="headerlink" title="2.更新代码步骤  （先检查当前状态，再更新，避免发生冲突）"></a>2.更新代码步骤  （先检查当前状态，再更新，避免发生冲突）</h2><p>2.1 git status  查看当前状态，查看本地分支文件信息</p>
<p>2.2 git check out -[file name] 若文件有修改，可以还原到最初状态; 若文件需要更新到服务器上，应该先merge到服务器，再更新到本地</p>
<p>2.3 git branch 查看本地所有分支，当前分支</p>
<p>2.4 git checkout remote branch   若分支为本地分支，则需切换到服务器的远程分支</p>
<p>2.5 git pull 更新本地代码</p>
<h2 id="3-提交代码步骤（先更新，在提交，避免冲突）"><a href="#3-提交代码步骤（先更新，在提交，避免冲突）" class="headerlink" title="3.提交代码步骤（先更新，在提交，避免冲突）"></a>3.提交代码步骤（先更新，在提交，避免冲突）</h2><p>3.1 git status  查看当前状态，查看本地分支文件信息</p>
<p>3.2 git branch 查看本地所有分支，当前分支</p>
<p>3.3 git checkout remote branch   若分支为本地分支，则需切换到服务器的远程分支</p>
<p>3.4 git push -u origin master    // 第一次推送时</p>
<pre><code>  git push origin master  // 第一次推送后，直接使用该命令即可推送修
</code></pre>
<p>常用git命令大全<br><a href="http://blog.csdn.net/liyayunwxc/article/details/10342573">http://blog.csdn.net/liyayunwxc/article/details/10342573</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb使用</title>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/mongodb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="mongo-中的数据类型"><a href="#mongo-中的数据类型" class="headerlink" title="mongo 中的数据类型"></a>mongo 中的数据类型</h3><p>Object ID： ⽂档 ID<br>String： 字符串， 最常⽤， 必须是有效的 UTF-8<br>Boolean： 存储⼀个布尔值， true 或 false<br>Integer： 整数可以是 32 位或 64 位， 这取决于服务器<br>Double： 存储浮点值<br>Arrays： 数组或列表， 多个值存储到⼀个键<br>Object： ⽤于嵌⼊式的⽂档， 即⼀个值为⼀个⽂档<br>Null： 存储 Null 值<br>Timestamp： 时间戳， 表示从 1970-1-1 到现在的总秒数<br>Date： 存储当前⽇期或时间的 UNIX 时间格式</p>
<h3 id="操作数据库命令"><a href="#操作数据库命令" class="headerlink" title="操作数据库命令"></a>操作数据库命令</h3><p>查看当前的数据库：db<br>查看所有的数据库：show dbs /show databases<br>切换数据库：use db_name 删除当前的数据库：db.dropDatabase()<br>切换到没有的数据库, 添加数据会自动创建<br>显示当前数据库状态：db.stats()<br>当前数据库版本：db.version()<br>查看当前数据库的链接机器地址：db.getMongo()</p>
<h3 id="操作集合的命令"><a href="#操作集合的命令" class="headerlink" title="操作集合的命令"></a>操作集合的命令</h3><p><em>向不存在的集合中第⼀次加⼊数据时， 集合会被创建出来</em></p>
<ul>
<li>创建用户：db.createUser({user:”laowang”,pwd:”123456”,roles:[{role:”userAdmin”,db:”stu”}]})<ul>
<li>b.createCollection(name,options)</li>
<li>db.createCollection(“stu”)</li>
<li>db.createCollection(“sub”, { capped : true, size : 10 } )<br>参数 capped： 默认值为 false 表示不设置上限,值为 true 表示设置上限<br>参数 size： 当 capped 值为 true 时， 需要指定此参数， 表示上限⼤⼩,单位为字节<br>当文档达到上限时， 会将之前的数据覆盖， 最早添加的数据移出, 其余上移, 最后添加在最后一条</li>
</ul>
</li>
</ul>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><ul>
<li>db.集合名称.insert(document)插⼊⽂档时， 如果不指定_id 参数， MongoDB 会为⽂档分配⼀个唯⼀的 ObjectId 类型的_id<br>db.stu.insert({name:’gj’,gender:1})<br>db.stu.insert({_id:”20170101”,name:’gj’,gender:1})</li>
</ul>
<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><ul>
<li>db.集合名称.save(document)<br>如果⽂档的_id 已经存在则修改， 如果⽂档的_id 不存在则添加<br>区别于: insert 如果存在直接报错</li>
</ul>
<h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询:"></a>简单查询:</h2><ul>
<li>db.集合名称.find()</li>
</ul>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li>语法: db.集合名称.update(<query> ,<update>,{multi: <boolean>})<br>参数 query:查询条件<br>参数 update:更新操作符<br>参数 multi:可选， 默认是 false，表示只更新找到的第⼀条记录， 值为 true 表示把满⾜条件的⽂档全部更新</li>
<li>举例:注意：”multi update only works with $ operators”  更新全部, 必须使用$set<br>db.stu.update({name:’hr’},{name:’mnc’}) 更新一条,没有更新的字段会丢弃.<br>db.stu.update({name:’hr’},{$set:{name:’hys’}}) 更新一条<br>db.stu.update({},{$set:{gender:0}},{multi:true}) 更新全部</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>语法: db.集合名称.remove(<query>,{justOne: <boolean>})<br>参数 query:可选，删除的⽂档的条件<br>参数 justOne:可选， 如果设为 true 或 1， 则只删除⼀条， 默认 false， 表示删除多条</li>
</ul>
<h3 id="管道聚集-aggregate"><a href="#管道聚集-aggregate" class="headerlink" title="管道聚集 aggregate"></a>管道聚集 aggregate</h3><p><a href="https://segmentfault.com/a/1190000004263347">https://segmentfault.com/a/1190000004263347</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql指令</title>
    <url>/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/mysql%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MYSQL-常用命令"><a href="#MYSQL-常用命令" class="headerlink" title="MYSQL 常用命令"></a>MYSQL 常用命令</h2><p><strong>1.导出整个数据库</strong><br>mysqldump -u 用户名 -p –default-character-set=latin1 数据库名 &gt; 导出的文件名(数据库默认编码是 latin1)<br>mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql<br><strong>2.导出一个表</strong><br>mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名<br>mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql<br><strong>3.导出一个数据库结构</strong><br>mysqldump -u wcnc -p -d –add-drop-table smgp_apps_wcnc &gt;d:wcnc_db.sql<br>-d 没有数据 –add-drop-table 在每个 create 语句之前增加一个 drop table<br><strong>4.导入数据库</strong><br>A:常用 source 命令<br>进入 mysql 数据库控制台，<br>如 mysql -u root -p<br>mysql&gt;use 数据库<br>然后使用 source 命令，后面参数为脚本文件(如这里用到的.sql)<br>mysql&gt;source wcnc_db.sql<br>B:使用 mysqldump 命令<br>mysqldump -u username -p dbname &lt; filename.sql<br>C:使用 mysql 命令<br>mysql -u username -p -D dbname &lt; filename.sql</p>
<h3 id="一、启动与退出"><a href="#一、启动与退出" class="headerlink" title="一、启动与退出"></a>一、启动与退出</h3><p>1、进入 MySQL：启动 MySQL Command Line Client（MySQL 的 DOS 界面），直接输入安装时的密码即可。此时的提示符是：mysql&gt;<br>2、退出 MySQL：quit 或 exit</p>
<h3 id="二、库操作"><a href="#二、库操作" class="headerlink" title="二、库操作"></a>二、库操作</h3><p>1、、创建数据库<br>命令：create database &lt;数据库名&gt;<br>例如：建立一个名为 xhkdb 的数据库<br>mysql&gt; create database xhkdb;<br>2、显示所有的数据库<br>命令：show databases （注意：最后有个 s）<br>mysql&gt; show databases;<br>3、删除数据库<br>命令：drop database &lt;数据库名&gt;<br>例如：删除名为 xhkdb 的数据库<br>mysql&gt; drop database xhkdb;<br>4、连接数据库<br>命令：use &lt;数据库名&gt;<br>例如：如果 xhkdb 数据库存在，尝试存取它：<br>mysql&gt; use xhkdb;<br>屏幕提示：Database changed<br>5、查看当前使用的数据库<br>mysql&gt; select database();<br>6、当前数据库包含的表信息：<br>mysql&gt; show tables; （注意：最后有个 s）</p>
<h3 id="三、表操作，操作之前应连接某个数据库"><a href="#三、表操作，操作之前应连接某个数据库" class="headerlink" title="三、表操作，操作之前应连接某个数据库"></a>三、表操作，操作之前应连接某个数据库</h3><p>1、建表<br>命令：create table &lt;表名&gt; ( &lt;字段名&gt; &lt;类型&gt; [,..&lt;字段名 n&gt; &lt;类型 n&gt;]);<br>mysql&gt; create table MyClass(</p>
<blockquote>
<p>id int(4) not null primary key auto_increment,<br>name char(20) not null,<br>sex int(4) not null default ’′,<br>degree double(16,2));<br>2、获取表结构<br>命令：desc 表名，或者 show columns from 表名<br>mysql&gt;DESCRIBE MyClass<br>mysql&gt; desc MyClass;<br>mysql&gt; show columns from MyClass;<br>3、删除表<br>命令：drop table &lt;表名&gt;<br>例如：删除表名为 MyClass 的表<br>mysql&gt; drop table MyClass;<br>4、插入数据<br>命令：insert into &lt;表名&gt; [( &lt;字段名&gt;[,..&lt;字段名 n &gt; ])] values ( 值 )[, ( 值 n )]<br>例如，往表 MyClass 中插入二条记录, 这二条记录表示：编号为的名为 Tom 的成绩为.45, 编号为 的名为 Joan 的成绩为.99，编号为 的名为 Wang 的成绩为.5.<br>mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’, 96.59);<br>5、查询表中的数据<br>1)、查询所有行<br>命令：select &lt;字段，字段，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;<br>例如：查看表 MyClass 中所有数据<br>mysql&gt; select from MyClass;<br>2）、查询前几行数据<br>例如：查看表 MyClass 中前行数据<br>mysql&gt; select from MyClass order by id limit 0,2;<br>或者：<br>mysql&gt; select from MyClass limit 0,2;<br>6、删除表中数据<br>命令：delete from 表名 where 表达式<br>例如：删除表 MyClass 中编号为 的记录<br>mysql&gt; delete from MyClass where id=1;<br>7、修改表中数据：update 表名 set 字段=新值,…where 条件<br>mysql&gt; update MyClass set name=’Mary’where id=1;<br>7、在表中增加字段：<br>命令：alter table 表名 add 字段 类型 其他;<br>例如：在表 MyClass 中添加了一个字段 passtest，类型为 int(4)，默认值为<br>mysql&gt; alter table MyClass add passtest int(4) default ’′<br>8、更改表名：<br>命令：rename table 原表名 to 新表名;<br>例如：在表 MyClass 名字更改为 YouClass<br>mysql&gt; rename table MyClass to YouClass;<br>更新字段内容<br>update 表名 set 字段名 = 新内容<br>update 表名 set 字段名 = replace(字段名,’旧内容’,’新内容’)</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS实现居中的方式</title>
    <url>/2021/04/11/CSS%E7%9B%B8%E5%85%B3/%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1、水平居中"><a href="#1、水平居中" class="headerlink" title="1、水平居中"></a>1、水平居中</h3><p><strong>行内元素水平居中</strong><br>利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;center-text&quot;</span>&gt;</span><br><span class="line">    简单是稳定的前提。</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>:<span class="number">60px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.center-text &#123;</span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-d89a386d0a12a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="text-align"></p>
<p><strong>块级元素水平居中</strong><br>此方法必须有固定的宽度，通过设置 margin: 0 auto 可以实现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center-block&quot;</span>&gt;</span></span><br><span class="line">        简单不先于复杂，而是在复杂之后。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.center-block &#123;</span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">8rem</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>:<span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:<span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>:<span class="number">#000</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-122fcd9fc8440156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="margin"></p>
<p><strong>多块级元素水平居中</strong></p>
<ul>
<li>利用 inline-block<br>如果一行中有两个或两个以上的块级元素，通过设置块级元素的显示类型为 inline-block 和父容器的 text-align 属性从而使多块级元素水平居中。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;inline-block&quot;</span>&gt;</span><br><span class="line">        简单不先于复杂</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;inline-block&quot;</span>&gt;</span><br><span class="line">        而是在复杂之后</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;inline-block&quot;</span>&gt;</span><br><span class="line">        简单不先于复杂，而是在复杂之后。</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.container &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.inline-block &#123;</span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">4rem</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">45px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &gt;<span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">45px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-d15f3df93fd6ba92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="inline-block"></p>
<ul>
<li>利用 displa: flex<br>利用弹性布局(flex)，实现水平居中，其中 justify-content 用于设置弹性盒子元素在主轴(横向)方向上的对齐方式。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;flex-center&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;</span><br><span class="line">        简单不先于复杂。</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;</span><br><span class="line">        简单不先于复杂，而是在复杂之后。</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;</span><br><span class="line">        而是在复杂之后。</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.flex-center &#123;</span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>:flex-end;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.flex-center</span> &gt;<span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">4rem</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#000</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.flex-center</span> &gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">45px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.flex-center</span> &gt;<span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">45px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-61c2593ed94d3d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex"></p>
<h3 id="2、垂直居中"><a href="#2、垂直居中" class="headerlink" title="2、垂直居中"></a>2、垂直居中</h3><p><strong>单行行内元素垂直居中</strong><br>通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    软件在能够复用前必须先能用。</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">#box &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">line-height</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-4a149d318dc310d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="line-height"></p>
<p><strong>多行元素垂直居中</strong></p>
<ul>
<li>利用表格布局<br>利用表布局的 vertical-align: middle 可以实现子元素的垂直居中 。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center-table&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;v-cell&quot;</span>&gt;</span></span><br><span class="line">        The more technology you learn,<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        the more you realize how little you know.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.center-table &#123;</span><br><span class="line"><span class="css">    <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.v-cell &#123;</span><br><span class="line"><span class="css">    <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">    <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-4182c9220bc0527f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vertical-align"></p>
<ul>
<li>利用 flex 布局<br>利用 flex 布局实现垂直居中，其中 flex-direction: column 定义主轴方向为纵向。flex 是在 CSS3 中定义，在较老的浏览器中存在兼容问题。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;center-flex&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        Dance like nobody <span class="keyword">is</span> watching,&lt;br&gt;</span><br><span class="line">        code like everybody <span class="keyword">is</span>.</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.center-flex &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-8989bf9e3b42f0a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex1"></p>
<p><strong>块级元素垂直居中</strong></p>
<ul>
<li>固定高度的块级元素<br>已知居中元素的高度和宽度，垂直居中问题就很简单。通过绝对定位元素距离顶部 50%，并设置 margin-top 向上偏移元素高度的一半，就可实现垂直居中。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;child&quot;</span>&gt;控制复杂性是计算机编程的本质。&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>:<span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#000</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-7e896650c33e6ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="chuizhijuzhong"></p>
<ul>
<li>未知高度的块级元素<br>当垂直居中的块级元素高度未知时，可以借助 CSS3 中的 transform 属性向 Y 轴反向偏移 50%的方法实现垂直居中，部分浏览器可能存在兼容性问题。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=&quot;<span class="symbol">parent</span>&quot;&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>=&quot;<span class="symbol">child</span>&quot;&gt;世界上有 <span class="symbol">10</span> 种人，懂二进制的和不懂二进制的。&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">12rem</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、水平垂直居中"><a href="#3、水平垂直居中" class="headerlink" title="3、水平垂直居中"></a>3、水平垂直居中</h3><ul>
<li>固定宽高元素水平垂直居中<br>通过 margin 平移元素整体宽度的一半，使元素水平垂直居中。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;child&quot;</span>&gt;控制复杂性是计算机编程的本质。&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">110px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-403dfa1d3853092a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平垂直居中1"></p>
<ul>
<li>未知宽高元素水平垂直居中<br>利用 2D 变换，在水平和垂直方向都反向平移宽高的一半，从而使元素水平垂直居中。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;child&quot;</span>&gt;当你试图解决一个你不理解的问题时，复杂化就产成了。当你试图解决一个你不理解的问题时，复杂化就产成了。&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: black;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-4d263c3e1283d635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平垂直居中2"></p>
<ul>
<li>利用 flex 布局<br>利用 flex 布局，其中 justify-content 用于设置或检索弹性盒子元素在主轴上方向上的对齐方式；而 align-items 属性定义 flex 子项在 flex 容器的当前行的侧轴方向上的对齐方式。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;child&quot;</span>&gt;Facebook wasn&#x27;t built <span class="keyword">in</span> a <span class="built_in">day</span>.&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.parent &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">140px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#f69c55</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6932056-5fae7cd5844be6a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平垂直居中3"></p>
<p>##居中总结图<br><img src="https://upload-images.jianshu.io/upload_images/6932056-f259f9253ab852b1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="总结"></p>
<p>参考: <a href="https://www.cnblogs.com/ghq120/p/10939835.html">https://www.cnblogs.com/ghq120/p/10939835.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Map</title>
    <url>/2021/04/23/ES6/Map/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 与 Object 类似，也是键值对的数据结构。Object 是键只接受字符串，Map 允许不同数据类型做为键</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">//<span class="built_in">Map</span>(<span class="number">2</span>) &#123;<span class="string">&quot;name&quot;</span> =&gt; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;title&quot;</span> =&gt; <span class="string">&quot;Author&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>等同于</span><br><span class="line">const map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">items.forEach(</span><br><span class="line">  ([key, value]) =&gt; map.set(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>构造函数 Map 的参数要求：任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">//Set(2) &#123;[&#x27;foo&#x27;,1],[&#x27;bar&#x27;,2]&#125;</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="keyword">set</span>);</span><br><span class="line"><span class="comment">//获取键为&#x27;foo&#x27; 的值</span></span><br><span class="line">m1.<span class="keyword">get</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>(m2);</span><br><span class="line">m3.<span class="keyword">get</span>(<span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">Map同一个键多次赋值，后面的值将覆盖前面的值。</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span></span><br><span class="line">.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="number">1</span>) <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一个未知的键，则返回undefined。</span></span><br><span class="line"><span class="keyword">new</span> Map().<span class="built_in">get</span>(<span class="string">&#x27;asdas&#x27;</span>)  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当读取的Map键是引用类型数据时</span></span><br><span class="line">let <span class="built_in">map</span> = <span class="keyword">new</span> Map([[[<span class="number">5</span>],<span class="string">&#x27;hello&#x27;</span>]])</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>([<span class="number">5</span>]) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当读取的Map键是undefined或null时，Map判定为同一个键</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(undefined, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(undefined) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(NaN, <span class="number">123</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(NaN) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h4 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h4>]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Set</title>
    <url>/2021/04/23/ES6/Set/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>ES6 提供了新的数据结构 Set。本身是一个构造函数。它类似于数组，但是成员的值都是唯一的，没有重复的值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Set();</span><br><span class="line">[<span class="meta">2, 3, 5, 4, 5, 2, 2</span>].forEach(x =&gt; s.<span class="keyword">add</span>(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向 Set 加入值的时候，不会发生类型转换,类似于===，不同的是两个NaN会被判定为相等</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set();</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> c = NaN;</span><br><span class="line"><span class="keyword">let</span> d = NaN</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(a);</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(b);</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(c);</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(d);</span><br><span class="line"><span class="comment">//Set(3) &#123;5,&#x27;5&#x27;,NaN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组去重</span></span><br><span class="line">[<span class="meta">...new Set(array)</span>]</span><br><span class="line">Array.<span class="keyword">from</span>(<span class="keyword">new</span> Set(array))</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串去重</span></span><br><span class="line">[<span class="meta">...new Set(&#x27;ababbc&#x27;)</span>].<span class="keyword">join</span>(<span class="string">&#x27;&#x27;</span>)   <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="实例属性和方法"><a href="#实例属性和方法" class="headerlink" title="实例属性和方法"></a>实例属性和方法</h4><p><strong>实例属性</strong></p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是 Set 函数。</li>
<li>Set.prototype.size：返回 Set 实例的成员总数。</li>
</ul>
<p><strong>实例方法</strong></p>
<ul>
<li>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</li>
<li>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>Set.prototype.has(value)：返回一个布尔值，表示该值是否为 Set 的成员。</li>
<li>Set.prototype.clear()：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">s.add<span class="comment">(1)</span>.add<span class="comment">(2)</span>.add<span class="comment">(2)</span>;</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has<span class="comment">(1)</span> <span class="comment">// true</span></span><br><span class="line">s.has<span class="comment">(2)</span> <span class="comment">// true</span></span><br><span class="line">s.has<span class="comment">(3)</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete<span class="comment">(2)</span>;  true</span><br><span class="line">s.has<span class="comment">(2)</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>遍历操作</strong></p>
<ul>
<li>Set.prototype.keys()：返回键名的遍历器</li>
<li>Set.prototype.values()：返回键值的遍历器</li>
<li>Set.prototype.entries()：返回键值对的遍历器</li>
<li>Set.prototype.forEach()：使用回调函数遍历每个成员</li>
</ul>
<p>Set.keys()与 Set.values()行为一致</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">let set = new Set([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> red</span><br><span class="line"><span class="regexp">//</span> green</span><br><span class="line"><span class="regexp">//</span> blue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> red</span><br><span class="line"><span class="regexp">//</span> green</span><br><span class="line"><span class="regexp">//</span> blue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;red&quot;</span>]</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&quot;green&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="regexp">//</span> [<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;blue&quot;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach(callback,obj)<ul>
<li>callback 回调函数<ul>
<li>value 值</li>
<li>key 键</li>
<li>set Set 本身</li>
</ul>
</li>
<li>obj 如果 callback 中使用 this，则提供绑定 this 的对象</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用forEach()key和value一致</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br></pre></td></tr></table></figure>

<p>Set 可以间接使用数组方法,轻松实现幷集，交集，差集</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="constructor">Set([1, 2, 3])</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="constructor">Set([4, 3, 2])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>, <span class="operator">...</span><span class="params">b</span>])</span>;</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; <span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="constructor">Set([<span class="operator">...</span><span class="params">a</span>].<span class="params">filter</span>(<span class="params">x</span> =&gt; !<span class="params">b</span>.<span class="params">has</span>(<span class="params">x</span>)</span>));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
